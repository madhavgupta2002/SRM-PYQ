{
  "paper_title": "Programming for Problem Solving (FJ II 21CSS101J Set C)",
  "source": "2024-04-01 CT2 SetC",
  "questions": [
    {
      "question_number": "1",
      "question_text": "List down the Advantages and limitations of multi-dimensional array initialization",
      "marks": 2,
      "answer": "Advantages of multi-dimensional array initialization:\n1.  **Readability**: Makes code cleaner and easier to understand when declaring and assigning initial values simultaneously.\n2.  **Convenience**: Allows direct assignment of values to all or a subset of elements at the time of declaration.\n3.  **Representation**: Ideal for representing tabular data structures like matrices, grids, or game boards.\n\nLimitations of multi-dimensional array initialization:\n1.  **Fixed Size**: Once declared and initialized, the size of the array is fixed, making it inflexible for dynamic data.\n2.  **Memory Consumption**: Can consume a significant amount of memory, especially for large dimensions.\n3.  **Type Homogeneity**: All elements must be of the same data type.\n4.  **Partial Initialization**: If not all elements are initialized, the remaining elements will be automatically initialized to zero for global/static arrays, but to garbage values for local arrays (unless explicitly set to zero).\n5.  **Compiler Inference**: While the first dimension can often be omitted during initialization (allowing the compiler to deduce it), subsequent dimensions must always be explicitly stated.",
      "answer_source": "generated",
      "chapter": "Unit 2: Introduction to Arrays -One Dimensional (1D) Array Declaration and initialization"
    },
    {
      "question_number": "2",
      "question_text": "Predict output of the following program\nint main()\n{ int a[][]={{1,2},{3,4}};\nint i,j;\nfor i=0; i<2; i++\nfor j=0; j<2; j++\nprintf(\"%d\",a[i][j]);\nreturn 0; }",
      "marks": 2,
      "answer": "The program declares a 2D integer array `a` and initializes it as a `2x2` matrix: `{{1, 2}, {3, 4}}`. The nested `for` loops iterate through `i` from 0 to 1 and `j` from 0 to 1. Inside the loop, `printf(\"%d\",a[i][j]);` prints the integer value of each element. Since there are no spaces or newlines in the `printf` format string, the output will be all numbers concatenated.\n\n**Output:**\n1234",
      "answer_source": "generated",
      "chapter": "Unit 2: Initializing and Accessing 2D Array, Array Programs – 2D"
    },
    {
      "question_number": "3",
      "question_text": "Discuss call by value and call by reference with an example",
      "marks": 2,
      "answer": "**Call by Value:**\nIn call by value, a copy of the actual parameter's value is passed to the function's formal parameter. Any modifications made to the formal parameter inside the function are local to that function and do not affect the original actual parameter in the calling function.\n\n*Example (Call by Value):*\n```c\n#include <stdio.h>\n\nvoid increment(int x) {\n    x = x + 1; // 'x' is a copy, original 'num' is not changed\n    printf(\"Inside function: x = %d\\n\", x);\n}\n\nint main() {\n    int num = 10;\n    printf(\"Before function call: num = %d\\n\", num);\n    increment(num);\n    printf(\"After function call: num = %d\\n\", num);\n    return 0;\n}\n/* Output:\nBefore function call: num = 10\nInside function: x = 11\nAfter function call: num = 10\n*/\n```\n\n**Call by Reference:**\nIn call by reference, the memory address of the actual parameter is passed to the function's formal parameter (which must be a pointer). This allows the function to directly access and modify the original value stored at that memory location. Any changes made through the pointer will reflect in the actual parameter.\n\n*Example (Call by Reference):*\n```c\n#include <stdio.h>\n\nvoid increment(int *x) {\n    *x = *x + 1; // Modifies the value at the address pointed to by 'x'\n    printf(\"Inside function: *x = %d\\n\", *x);\n}\n\nint main() {\n    int num = 10;\n    printf(\"Before function call: num = %d\\n\", num);\n    increment(&num); // Pass the address of 'num'\n    printf(\"After function call: num = %d\\n\", num);\n    return 0;\n}\n/* Output:\nBefore function call: num = 10\nInside function: *x = 11\nAfter function call: num = 11\n*/\n```",
      "answer_source": "generated",
      "chapter": "Unit 3: Call by Value, Call by Reference"
    },
    {
      "question_number": "4",
      "question_text": "Write a C program to find the length of a string",
      "marks": 2,
      "answer": "```c\n#include <stdio.h>\n#include <string.h> // Required for strlen() function\n\nint main() {\n    char myString[] = \"Programming for Problem Solving\";\n    int length_builtin;\n    int length_manual = 0;\n\n    // Method 1: Using the built-in strlen() function\n    length_builtin = strlen(myString);\n    printf(\"String: \"%s\"\\n\", myString);\n    printf(\"Length using strlen(): %d\\n\", length_builtin);\n\n    // Method 2: Manually calculating length using a loop\n    // Iterate until the null terminator ('\\0') is found\n    while (myString[length_manual] != '\\0') {\n        length_manual++;\n    }\n    printf(\"Length calculated manually: %d\\n\", length_manual);\n\n    return 0;\n}\n```",
      "answer_source": "generated",
      "chapter": "Unit 3: Built-inString Functions: atoi, strlen, strcat, strcmp"
    },
    {
      "question_number": "5(a)",
      "question_text": "Explain in detail about the declaration of two-dimensional arrays, its initialization with suitable examples",
      "marks": 8,
      "answer": "**Declaration of Two-Dimensional Arrays:**\nA two-dimensional (2D) array is an array of arrays, representing data in a tabular form (rows and columns). It is declared by specifying the data type of elements, the array name, and two dimensions: the number of rows and the number of columns.\n\n**Syntax:** `data_type array_name[number_of_rows][number_of_columns];`\n\n*   `data_type`: The type of elements (e.g., `int`, `float`, `char`).\n*   `array_name`: The identifier for the array.\n*   `number_of_rows`: An integer constant specifying the number of rows.\n*   `number_of_columns`: An integer constant specifying the number of columns.\n\n*Example Declaration:*\n```c\nint matrix[3][4]; // Declares a 2D integer array with 3 rows and 4 columns.\nchar board[8][8]; // Declares a 2D character array for an 8x8 game board.\n```\nThis `matrix[3][4]` array can store `3 * 4 = 12` integer elements. Elements are accessed using `array_name[row_index][column_index]`, where `row_index` ranges from `0` to `number_of_rows - 1` and `column_index` from `0` to `number_of_columns - 1`.\n\n**Initialization of Two-Dimensional Arrays:**\n2D arrays can be initialized at the time of declaration in several ways:\n\n1.  **Direct Initialization (Complete):**\n    You can initialize all elements by providing values enclosed in nested curly braces `{}`. Each inner curly brace represents a row.\n    *Example:*\n    ```c\n    int matrix[2][3] = { {1, 2, 3},   // Row 0\n                           {4, 5, 6} }; // Row 1\n    /* This initializes:\n       matrix[0][0] = 1, matrix[0][1] = 2, matrix[0][2] = 3\n       matrix[1][0] = 4, matrix[1][1] = 5, matrix[1][2] = 6\n    */\n    ```\n\n2.  **Partial Initialization:**\n    If you provide fewer initializer values than the array's capacity, the remaining elements are automatically initialized to zero (for static/global arrays) or will contain garbage values (for local arrays).\n    *Example:*\n    ```c\n    int partialMatrix[2][3] = { {1, 2},   // Only two elements for row 0\n                                {4} };    // Only one element for row 1\n    /* This initializes:\n       partialMatrix[0][0] = 1, partialMatrix[0][1] = 2, partialMatrix[0][2] = 0\n       partialMatrix[1][0] = 4, partialMatrix[1][1] = 0, partialMatrix[1][2] = 0\n    */\n    ```\n\n3.  **Initialization without specifying Row Size:**\n    The number of rows can be omitted during initialization, and the compiler will automatically calculate it based on the number of initializer lists provided. However, the column size must always be specified.\n    *Example:*\n    ```c\n    int dynamicRows[][3] = { {10, 20, 30},\n                             {40, 50, 60},\n                             {70, 80, 90} };\n    // The compiler deduces that dynamicRows has 3 rows and 3 columns.\n    ```\n\n4.  **Omitting Inner Braces (not recommended for clarity):**\n    You can omit the inner curly braces for rows, but the values are assigned sequentially.\n    *Example:*\n    ```c\n    int sequentialMatrix[2][3] = {1, 2, 3, 4, 5, 6};\n    /* This is equivalent to:\n       sequentialMatrix[0][0] = 1, sequentialMatrix[0][1] = 2, sequentialMatrix[0][2] = 3\n       sequentialMatrix[1][0] = 4, sequentialMatrix[1][1] = 5, sequentialMatrix[1][2] = 6\n    */\n    ```\n    While syntactically valid, this approach can reduce code readability and make it harder to visually map values to rows/columns.",
      "answer_source": "generated",
      "chapter": "Unit 2: Initializing and Accessing 2D Array, Array Programs – 2D"
    },
    {
      "question_number": "5(b)",
      "question_text": "Write a program to illustrate the use of indirection operator '*' to access the value pointed to by a pointer.",
      "marks": 8,
      "answer": "The indirection operator (`*`), also known as the dereference operator, is used to access the value stored at the memory address pointed to by a pointer. When applied to a pointer variable, it \"dereferences\" the pointer, giving you the content of the memory location it points to.\n\n```c\n#include <stdio.h>\n\nint main() {\n    int var = 10;   // Declare an integer variable 'var' and initialize it to 10\n    int *ptr;       // Declare an integer pointer 'ptr'\n\n    // 1. Assign the address of 'var' to 'ptr' using the address-of operator '&'\n    ptr = &var;\n\n    printf(\"--- Initial State ---\\n\");\n    printf(\"Value of var: %d\\n\", var);                       // Output: 10\n    printf(\"Address of var: %p\\n\", (void*)&var);            // Output: (e.g.) 0x7ffee21c7d84\n    printf(\"Value stored in ptr (address of var): %p\\n\", (void*)ptr); // Output: (e.g.) 0x7ffee21c7d84\n\n    // 2. Use the indirection operator '*' to access the value pointed to by 'ptr'\n    printf(\"\\n--- Accessing value via pointer ---\\n\");\n    printf(\"Value accessed via *ptr: %d\\n\", *ptr);           // Output: 10 (Dereferencing ptr)\n\n    // 3. Use the indirection operator '*' to modify the value pointed to by 'ptr'\n    *ptr = 20; // Change the value at the address 'ptr' points to\n\n    printf(\"\\n--- Modifying value via pointer ---\\n\");\n    printf(\"Value accessed via *ptr after modification: %d\\n\", *ptr); // Output: 20\n    printf(\"Value of var after modification via pointer: %d\\n\", var); // Output: 20 (Original var is changed)\n\n    // Example with another data type (float)\n    float pi = 3.14;\n    float *fptr = &pi; // Pointer to float\n\n    printf(\"\\n--- Example with float pointer ---\\n\");\n    printf(\"Value of pi: %.2f\\n\", pi);\n    printf(\"Value accessed via *fptr: %.2f\\n\", *fptr);\n\n    return 0;\n}\n```\n**Explanation:**\n1.  `int var = 10;`: An integer variable `var` is created with value 10.\n2.  `int *ptr;`: An integer pointer `ptr` is declared, which can store the address of an `int` variable.\n3.  `ptr = &var;`: The `&` (address-of) operator gives the memory address of `var`, which is then assigned to `ptr`. Now `ptr` points to `var`.\n4.  `*ptr`: The indirection operator `*` when applied to `ptr` retrieves the value currently stored at the memory address that `ptr` holds. In this case, `*ptr` evaluates to `10`.\n5.  `*ptr = 20;`: When `*ptr` is used on the left-hand side of an assignment, it means assign this value to the memory location pointed to by `ptr`. This effectively changes the value of `var` to `20`.",
      "answer_source": "generated",
      "chapter": "Unit 2: Pointer Declaration and dereferencing, Void Pointers, Null pointers"
    },
    {
      "question_number": "6",
      "question_text": "Explain in details about string functions: gets(), puts(), getchar(), putchar(), printf(), with an example programs",
      "marks": 8,
      "answer": "These functions are fundamental for input/output operations in C, especially when dealing with characters and strings.\n\n1.  **`gets()` - Get String from Standard Input**\n    *   **Purpose**: Reads a line of text from the standard input (`stdin`) and stores it into the character array (string) specified by its argument. It continues reading characters until a newline character (`\\n`) or End-Of-File (EOF) is encountered. The newline character is not stored, but replaced with a null terminator (`\\0`).\n    *   **Syntax**: `char *gets(char *str);`\n    *   **Warning**: `gets()` is highly insecure because it doesn't check the buffer size, making it vulnerable to buffer overflows if the input string is longer than the allocated buffer. It is deprecated and `fgets()` is the recommended alternative.\n\n2.  **`puts()` - Put String to Standard Output**\n    *   **Purpose**: Writes the null-terminated string pointed to by its argument to the standard output (`stdout`), followed by an automatically appended newline character (`\\n`).\n    *   **Syntax**: `int puts(const char *str);`\n\n3.  **`getchar()` - Get Character from Standard Input**\n    *   **Purpose**: Reads a single character from the standard input (`stdin`). It returns the character read as an `int` (to accommodate `EOF`), or `EOF` on failure.\n    *   **Syntax**: `int getchar(void);`\n\n4.  **`putchar()` - Put Character to Standard Output**\n    *   **Purpose**: Writes a single character to the standard output (`stdout`). It returns the character written as an `int`, or `EOF` on failure.\n    *   **Syntax**: `int putchar(int char_to_write);`\n\n5.  **`printf()` - Print Formatted Output**\n    *   **Purpose**: A powerful and versatile function used for formatted output. It writes output to the standard output (`stdout`) under the control of a format string. The format string can contain text and format specifiers (e.g., `%d` for integer, `%s` for string, `%f` for float) that dictate how subsequent arguments are converted and printed.\n    *   **Syntax**: `int printf(const char *format, ...);`\n\n**Example Program illustrating all functions:**\n```c\n#include <stdio.h>\n\nint main() {\n    char name[50];\n    char singleChar;\n    int age = 30;\n    float salary = 55000.75;\n\n    // Demonstrate gets() and puts()\n    printf(\"Enter your name: \");\n    // Using gets() - Warning: Insecure, prefer fgets() in real applications.\n    gets(name); \n    printf(\"Hello, \");\n    puts(name); // puts() adds a newline at the end\n\n    // Demonstrate getchar() and putchar()\n    printf(\"Enter a single character: \");\n    singleChar = getchar(); // Reads one character\n    // Clear the input buffer to prevent issues with subsequent inputs\n    while (getchar() != '\\n' && getchar() != EOF);\n\n    printf(\"You entered: \");\n    putchar(singleChar);\n    putchar('\\n'); // Manually add a newline after the character\n\n    // Demonstrate printf()\n    printf(\"Using printf: Your age is %d and your salary is %.2f.\\n\", age, salary);\n    printf(\"Current year: %d.\\n\", 2024);\n\n    return 0;\n}\n```",
      "answer_source": "generated",
      "chapter": "Unit 3: String Functions: gets(), puts(), getchar(),putchar(), printf()"
    },
    {
      "question_number": "7",
      "question_text": "Design a program to copy one string into another and count the number of characters copied. (i) using string function (ii) without using string function",
      "marks": 8,
      "answer": "```c\n#include <stdio.h>\n#include <string.h> // Required for strcpy and strlen\n\nint main() {\n    char source_str_1[] = \"Hello, C Programming!\";\n    char destination_str_1[50]; // Ensure enough space for the copied string\n    int chars_copied_1 = 0;\n\n    // (i) Using string functions (strcpy and strlen)\n    printf(\"--- (i) Using built-in string functions ---\\n\");\n    printf(\"Source string: \"%s\"\\n\", source_str_1);\n\n    // Copy the string using strcpy()\n    strcpy(destination_str_1, source_str_1);\n\n    // Count characters using strlen()\n    chars_copied_1 = strlen(source_str_1);\n    // Note: strlen counts characters until the null terminator, excluding the null terminator itself.\n\n    printf(\"Destination string: \"%s\"\\n\", destination_str_1);\n    printf(\"Number of characters copied: %d\\n\", chars_copied_1); // Prints 21\n\n    printf(\"\\n\");\n\n    char source_str_2[] = \"Copy me manually.\";\n    char destination_str_2[50];\n    int i = 0;\n    int chars_copied_2 = 0;\n\n    // (ii) Without using string functions (manual copy)\n    printf(\"--- (ii) Without using built-in string functions ---\\n\");\n    printf(\"Source string: \"%s\"\\n\", source_str_2);\n\n    while (source_str_2[i] != '\\0') {\n        destination_str_2[i] = source_str_2[i];\n        chars_copied_2++;\n        i++;\n    }\n    destination_str_2[i] = '\\0'; // Crucially, add the null terminator at the end\n\n    printf(\"Destination string: \"%s\"\\n\", destination_str_2);\n    printf(\"Number of characters copied: %d\\n\", chars_copied_2); // Prints 17\n\n    return 0;\n}\n```",
      "answer_source": "generated",
      "chapter": "Unit 3: Built-inString Functions: atoi, strlen, strcat, strcmp"
    },
    {
      "question_number": "8",
      "question_text": "Explain function with and without Arguments and having a Return Value with suitable examples.",
      "marks": 8,
      "answer": "In C programming, functions can be categorized based on whether they accept arguments and whether they return a value. This question specifically asks about functions that *have* a return value.\n\n1.  **Function with Arguments and having a Return Value:**\n    *   **Description**: These functions take one or more input values (arguments) from the calling function to perform their task. After completing the operation, they compute a result and send it back to the calling function using a `return` statement. The return type specifies the data type of the value being returned.\n    *   **Use Case**: Ideal for computations where inputs are provided by the caller, and a specific result needs to be delivered back.\n    *   **Example**: A function that calculates the sum of two numbers.\n    ```c\n    #include <stdio.h>\n\n    // Function declaration: takes two integers, returns an integer\n    int addNumbers(int a, int b) {\n        int sum = a + b;\n        return sum; // Returns the calculated sum\n    }\n\n    int main() {\n        int num1 = 10, num2 = 20;\n        // Call the function with arguments and store the returned value\n        int result = addNumbers(num1, num2);\n        printf(\"The sum of %d and %d is: %d\\n\", num1, num2, result); // Output: 30\n        return 0;\n    }\n    ```\n\n2.  **Function without Arguments and having a Return Value:**\n    *   **Description**: These functions do not accept any input values from the calling function. They perform their task internally (e.g., getting input from the user, performing a fixed calculation) and then return a single value to the calling function. The return type specifies the data type of the value being returned.\n    *   **Use Case**: Suitable for operations where all necessary data is generated or accessed internally by the function, and only the final result is needed by the caller.\n    *   **Example**: A function that prompts the user for a number and returns it.\n    ```c\n    #include <stdio.h>\n\n    // Function declaration: takes no arguments, returns an integer\n    int getUserInput() {\n        int input;\n        printf(\"Please enter an integer: \");\n        scanf(\"%d\", &input);\n        return input; // Returns the value entered by the user\n    }\n\n    int main() {\n        // Call the function without arguments and store the returned value\n        int number = getUserInput();\n        printf(\"You entered: %d\\n\", number);\n\n        // Example 2: Function calculating a fixed value\n        printf(\"Fixed calculation result: %d\\n\", calculateFixedValue());\n        return 0;\n    }\n\n    // Another example of a function without arguments but with return value\n    int calculateFixedValue() {\n        return 100 * 2 + 5;\n    }\n    ```",
      "answer_source": "generated",
      "chapter": "Unit 3: Function with and without Arguments - Function with and without return values"
    },
    {
      "question_number": "9",
      "question_text": "Using a C program function sort an array of integers.",
      "marks": 8,
      "answer": "This program demonstrates sorting an array of integers using a function. We'll implement a simple Bubble Sort algorithm within a function.\n\n```c\n#include <stdio.h>\n\n// Function to sort an array of integers using Bubble Sort\n// It takes an integer array and its size as arguments.\n// The array is passed by reference (its base address), so changes reflect in main.\nvoid sortArrayAscending(int arr[], int size) {\n    int i, j, temp; // Loop counters and temporary variable for swapping\n\n    // Outer loop for passes (size-1 passes are sufficient)\n    for (i = 0; i < size - 1; i++) {\n        // Inner loop for comparisons and swaps in each pass\n        // The largest element 'bubbles up' to its correct position in each pass\n        for (j = 0; j < size - i - 1; j++) {\n            // Compare adjacent elements\n            if (arr[j] > arr[j + 1]) {\n                // Swap if the current element is greater than the next\n                temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n}\n\n// Function to print the elements of an array\nvoid printArray(int arr[], int size) {\n    int i;\n    for (i = 0; i < size; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    int numbers[] = {64, 34, 25, 12, 22, 11, 90}; // The array to be sorted\n    int n = sizeof(numbers) / sizeof(numbers[0]); // Calculate the size of the array\n\n    printf(\"Original array: \");\n    printArray(numbers, n); // Print the array before sorting\n\n    // Call the sorting function\n    sortArrayAscending(numbers, n);\n\n    printf(\"Sorted array (Ascending): \");\n    printArray(numbers, n); // Print the array after sorting\n\n    return 0;\n}\n```\n**Explanation:**\n1.  **`sortArrayAscending(int arr[], int size)` function:**\n    *   This function takes an integer array `arr` and its `size` as input.\n    *   It implements the Bubble Sort algorithm. The outer loop runs `size-1` times, representing the number of passes needed.\n    *   The inner loop iterates through the unsorted part of the array, comparing adjacent elements.\n    *   If an element is greater than its right neighbor, they are swapped using a temporary variable `temp`.\n    *   Because arrays are passed by reference (the base address of the array is passed), any modifications inside `sortArrayAscending` directly affect the original `numbers` array in `main()`.\n2.  **`printArray(int arr[], int size)` function:**\n    *   A utility function to display the contents of an array.\n3.  **`main()` function:**\n    *   An array `numbers` is initialized with unsorted values.\n    *   The `sizeof` operator is used to dynamically calculate the number of elements `n` in the array.\n    *   The original array is printed.\n    *   `sortArrayAscending()` is called to sort the array.\n    *   The sorted array is then printed.",
      "answer_source": "generated",
      "chapter": "Unit 3: Passing Array to Function"
    }
  ]
}