{
    "paper_title": "Programming For Problem Solving (SRM Institute of Science and Technology)",
    "source": "2021-01-12 CT2",
    "questions": [
        {
            "question_number": "1.",
            "question_text": "Which of the following operator takes only integer operands?\nA) +\nB) /\nC) %\nD) None of these",
            "marks": 1,
            "answer": "The modulo operator (`%`) in C primarily takes only integer operands. While `+` (addition) and `/` (division) can operate on both integer and floating-point types, the `%` operator is specifically for finding the remainder of an integer division. Therefore, option C is correct.",
            "answer_source": "generated",
            "chapter": "Unit 1: Arithmetic, Relational and logical Operators"
        },
        {
            "question_number": "2.",
            "question_text": "In an expression involving || operator, evaluation\nI) Will be stopped if one of its components evaluates to false\nII) Will be stopped if one of its components evaluates to true\nIII) Takes place from right to left\nIV) Takes place from left to right\nA) I and II\nB) I and III\nC) II and III\nD) II and IV",
            "marks": 1,
            "answer": "The logical OR operator (`||`) in C uses short-circuit evaluation. This means:\nII) Evaluation will be stopped if one of its components evaluates to true, because if any operand is true, the entire OR expression is true, and there's no need to evaluate further operands.\nIV) Evaluation takes place from left to right.\nTherefore, options II and IV are correct, making D the correct choice.",
            "answer_source": "generated",
            "chapter": "Unit 1: Arithmetic, Relational and logical Operators, Operator Precedence"
        },
        {
            "question_number": "3.",
            "question_text": "Find the output of the following:\nvoid main()\n{\nint i=0, j=1, k=2, m;\nm= i++ || j++ || k++ ;\nprintf(\"%d %d %d %d\", m, i, j, k);\n}",
            "marks": 1,
            "answer": "Let's trace the execution:\n1.  `int i=0, j=1, k=2, m;`\n2.  `m = i++ || j++ || k++;`\n    *   `i++` evaluates to `0` (false). `i` becomes `1`. \n    *   Since the left operand of `||` was false, `j++` is evaluated. `j++` evaluates to `1` (true). `j` becomes `2`. \n    *   Due to short-circuiting, `k++` is NOT evaluated because the result of `j++` being true already determines the outcome of the `||` expression. `k` remains `2`. \n    *   The entire expression `i++ || j++ || k++` evaluates to true, which, when assigned to an integer `m`, typically results in `1` (or a non-zero value, often `1` by convention).\n    *   So, `m` becomes `1`.\n3.  `printf(\"%d %d %d %d\", m, i, j, k);` prints the current values of `m`, `i`, `j`, and `k`.\n    *   `m` is `1`\n    *   `i` is `1`\n    *   `j` is `2`\n    *   `k` is `2`\n\nThe output is `1 1 2 2`. Therefore, option B is correct.",
            "answer_source": "generated",
            "chapter": "Unit 1: Expressions with pre / post increment operator, Logical Operators"
        },
        {
            "question_number": "4.",
            "question_text": "What will be the output?\nvoid main()\n{\nint a=10, b=20;\nchar x=1, y=0;\nif(a,b,x,y)\nprintf(\u201cEXAM\u201d);\n}",
            "marks": 1,
            "answer": "The `if` statement evaluates the expression `(a,b,x,y)`. This uses the comma operator. The comma operator evaluates its operands from left to right and the result of the entire expression is the value of its rightmost operand. In this case, the expression `(a,b,x,y)` evaluates to the value of `y`. Since `y` is initialized to `0`, the condition `if(0)` is false. Therefore, the `printf(\u201cEXAM\u201d);` statement inside the `if` block will not be executed, and the program will print nothing. Option D is correct.",
            "answer_source": "generated",
            "chapter": "Unit 1: Comma, Arrow and Assignment operator, Conditional Operators"
        },
        {
            "question_number": "5.",
            "question_text": "Which operator from the following has the lowest priority?\nA) Assignment\nB) Division\nC) Comma\nD) Dot",
            "marks": 1,
            "answer": "In C operator precedence:\n*   The Dot operator (`.`) has very high precedence (highest in the options).\n*   Division (`/`) has high precedence (arithmetic operators).\n*   Assignment (`=`) has lower precedence than arithmetic but higher than comma.\n*   The Comma operator (`,`) has the lowest precedence among all C operators. \nTherefore, option C is correct.",
            "answer_source": "generated",
            "chapter": "Unit 1: Comma, Arrow and Assignment operator, Operator Precedence"
        },
        {
            "question_number": "6.",
            "question_text": "Array elements are always stored in --------- memory locations.\nA) Sequential\nB) Random\nC) Sequential and Random\nD) None of these",
            "marks": 1,
            "answer": "Array elements in C are always stored in contiguous (sequential) memory locations. This property is fundamental to how arrays work and allows for efficient direct access to elements using an index. Therefore, option A is correct.",
            "answer_source": "generated",
            "chapter": "Unit 2: Introduction to Arrays -One Dimensional (1D) Array Declaration and initialization"
        },
        {
            "question_number": "7.",
            "question_text": "Let x be an array. Which of the following operations are illegal\n(throws error)?\nI) ++x\nII) x+1\nIII) x++\nIV) x*2\nA) I and II\nB) III and IV\nC) I, II and III\nD) I, III and IV",
            "marks": 1,
            "answer": "In C, an array name `x` acts as a constant pointer to its first element. This means its address value cannot be changed after declaration.\n*   `I) ++x`: Illegal. You cannot increment a constant pointer.\n*   `II) x+1`: Legal. This is valid pointer arithmetic, which results in a pointer to the next element. It does not modify `x` itself, but rather computes a new address.\n*   `III) x++`: Illegal. You cannot increment a constant pointer.\n*   `IV) x*2`: Illegal. You cannot multiply a pointer by an integer directly.\n\nTherefore, I, III, and IV are illegal operations. Option D is correct.",
            "answer_source": "generated",
            "chapter": "Unit 2: Pointer based Array manipulation"
        },
        {
            "question_number": "8.",
            "question_text": "What is the output of C Program.?\nint main() { int a[3] = {10,12,14}; a[1]=20; int i=0; while(i<3) {\nprintf(\"%d \", a[i]); i++; } }",
            "marks": 1,
            "answer": "Let's trace the program execution:\n1.  `int a[3] = {10,12,14};` initializes the array `a` as `a[0]=10, a[1]=12, a[2]=14`.\n2.  `a[1]=20;` modifies the array. Now `a` is `{10, 20, 14}`.\n3.  `int i=0;` initializes `i` to 0.\n4.  The `while (i<3)` loop starts:\n    *   **i=0:** `i < 3` is true. `printf(\"%d \", a[0]);` prints `10 `. `i` becomes `1`.\n    *   **i=1:** `i < 3` is true. `printf(\"%d \", a[1]);` prints `20 `. `i` becomes `2`.\n    *   **i=2:** `i < 3` is true. `printf(\"%d \", a[2]);` prints `14 `. `i` becomes `3`.\n    *   **i=3:** `i < 3` is false. The loop terminates.\n\nThe final output is `10 20 14 `. Therefore, option B is correct.",
            "answer_source": "generated",
            "chapter": "Unit 2: Looping Control Statements: while, Accessing, Indexing and operations with 1D Arrays"
        },
        {
            "question_number": "9.",
            "question_text": "What is the Format specifier used to print a String or Character\narray in C Printf or Scanf function?\nA) %c\nB) %C\nC) %s\nD) %w",
            "marks": 1,
            "answer": "The format specifier `%s` is used to print or read a null-terminated string (character array) in C's `printf` and `scanf` functions. `%c` is used for a single character. Therefore, option C is correct.",
            "answer_source": "generated",
            "chapter": "Unit 3: String Functions: gets(), puts(), getchar(),putchar(), printf()"
        },
        {
            "question_number": "10.",
            "question_text": "What is the output of this C code?\nint main()\n{\nint foo();\n{\nvoid foo();\n}\nvoid foo()\n{\nprintf(\"2 \");\n}\nvoid f()\n{\nprintf(\"1 \");\nfoo();\n}\n\nA. Compile time error as foo is local to main\nB. 1 2\nC. 2 1\nD. Compile time error due to declaration of functions inside main",
            "marks": 1,
            "answer": "This code will result in a compile-time error. In C, a function's return type is part of its signature. Here, `foo` is declared with two conflicting return types:\n1.  `int foo();` inside `main()`.\n2.  `void foo();` inside a block within `main()` and also as its global definition `void foo() {...}`.\n\nWhile the declarations inside `main` are local to `main`'s scope, the global definition of `foo` is `void`. If `main` were to call `foo()`, the compiler would use the `int foo();` prototype it saw, and then during linking, it would find a definition for `void foo()`, leading to a type mismatch error. Even without a call, many compilers will flag conflicting declarations for the same function within the same compilation unit. The most accurate description of the problem is conflicting declarations. Therefore, option D is correct.",
            "answer_source": "generated",
            "chapter": "Unit 3: Function prototype declaration, function definition"
        },
        {
            "question_number": "11.",
            "question_text": "Write C program to input a sequence of characters from user and check whether given character array has an alphabet or digit or special character using if else.",
            "marks": 4,
            "answer": "```c\n#include <stdio.h>\n#include <ctype.h>  // For isalpha, isdigit, isgraph, isspace\n#include <string.h> // For strcspn\n\nint main() {\n    char input[100]; // Declare a character array (string)\n    int i;\n    int has_alpha = 0;\n    int has_digit = 0;\n    int has_special = 0;\n\n    printf(\"Enter a sequence of characters (max 99 chars): \");\n    fgets(input, sizeof(input), stdin); // Read input including spaces\n\n    // Remove trailing newline character added by fgets, if present\n    input[strcspn(input, \"\\n\")] = 0;\n\n    // Iterate through the string to check each character\n    for (i = 0; input[i] != '\\0'; i++) {\n        if (isalpha(input[i])) {\n            has_alpha = 1;\n        } else if (isdigit(input[i])) {\n            has_digit = 1;\n        } else if (isgraph(input[i]) && !isspace(input[i])) { \n            // isgraph checks for any printable character except space\n            // !isspace ensures we don't count spaces as special characters\n            has_special = 1;\n        }\n    }\n\n    printf(\"\\nAnalysis of the input string:\\n\");\n    if (has_alpha) {\n        printf(\"- Contains alphabetic characters.\\n\");\n    }\n    if (has_digit) {\n        printf(\"- Contains digit characters.\\n\");\n    }\n    if (has_special) {\n        printf(\"- Contains special characters (non-alphanumeric, non-space printable).\\n\");\n    }\n    if (!has_alpha && !has_digit && !has_special) {\n        printf(\"- Contains only spaces or non-printable characters.\\n\");\n    }\n\n    return 0;\n}\n```",
            "answer_source": "generated",
            "chapter": "Unit 2: Conditional Control -Statements :Simple if, if...else; Looping Control Statements: for; Unit 3: String Functions: gets(), puts(), getchar(),putchar(), printf()"
        },
        {
            "question_number": "12.",
            "question_text": "Discuss the Conditional iterators in C language.",
            "marks": 4,
            "answer": "The term \"Conditional iterators\" is not a standard C programming term. However, it likely refers to the combination of **Conditional Control Statements** (for making decisions) and **Looping Control Statements** (for iteration based on conditions) in C. These are fundamental for controlling program flow. \n\n**Conditional Control Statements (Decision Making):**\nThese statements allow a program to execute different blocks of code based on whether a condition is true or false.\n1.  **`if` statement:** Executes a block of code if the given condition is true.\n    ```c\n    if (condition) {\n        // Code to execute if condition is true\n    }\n    ```\n2.  **`if...else` statement:** Executes one block if the condition is true, and another block if it's false.\n    ```c\n    if (condition) {\n        // Code for true condition\n    } else {\n        // Code for false condition\n    }\n    ```\n3.  **`else if` ladder:** Used to test a series of conditions sequentially.\n    ```c\n    if (condition1) {\n        // Code for condition1\n    } else if (condition2) {\n        // Code for condition2\n    } else {\n        // Code if none of the above are true\n    }\n    ```\n4.  **`switch` statement:** Provides a way to choose one of many code blocks to be executed, based on the value of a single expression.\n    ```c\n    switch (expression) {\n        case value1:\n            // Code for value1\n            break;\n        case value2:\n            // Code for value2\n            break;\n        default:\n            // Code if no match\n    }\n    ```\n\n**Looping Control Statements (Iteration based on a condition):**\nThese statements allow a block of code to be executed repeatedly as long as a certain condition remains true.\n1.  **`while` loop:** The loop body executes repeatedly as long as its condition is true. The condition is checked *before* each iteration. If the condition is initially false, the loop body never executes.\n    ```c\n    while (condition) {\n        // Code to repeat\n    }\n    ```\n2.  **`do...while` loop:** Similar to `while`, but the loop body executes *at least once* before the condition is checked. The loop continues as long as the condition is true.\n    ```c\n    do {\n        // Code to repeat\n    } while (condition);\n    ```\n3.  **`for` loop:** A compact way to handle loops where the initialization, condition, and increment/decrement of a loop variable are known. It's often used when the number of iterations is predetermined.\n    ```c\n    for (initialization; condition; increment/decrement) {\n        // Code to repeat\n    }\n    ```\n\nThese conditional and looping constructs, sometimes conceptually referred to as 'conditional iterators' in a broader sense, are essential for implementing algorithms and solving problems by allowing programs to dynamically respond to data and conditions.",
            "answer_source": "generated",
            "chapter": "Unit 2: Conditional Control -Statements; Looping Control Statements: for, while, do.while"
        },
        {
            "question_number": "13.",
            "question_text": "Write short notes on: strrev, strcpy, strstr, strtok",
            "marks": 4,
            "answer": "These are common string manipulation functions in C, primarily found in the `<string.h>` header.\n\n1.  **`strrev()` (String Reverse):**\n    *   **Purpose:** Reverses the order of characters in a null-terminated string.\n    *   **Syntax (common non-standard prototype):** `char *strrev(char *str);`\n    *   **Description:** It modifies the input string `str` in-place, reversing its character sequence. It typically returns a pointer to the modified string. It's important to note that `strrev()` is a non-standard function, often found in compilers like Turbo C/C++, but not part of the ISO C standard (C99, C11). For standard C, string reversal would require a manual implementation.\n\n2.  **`strcpy()` (String Copy):**\n    *   **Purpose:** Copies the content of a source string to a destination string.\n    *   **Syntax:** `char *strcpy(char *destination, const char *source);`\n    *   **Description:** This function copies the null-terminated string pointed to by `source` (including the null terminator) to the character array pointed to by `destination`. The `destination` array must be large enough to hold the entire `source` string, otherwise, it can lead to a buffer overflow. It returns a pointer to `destination`.\n\n3.  **`strstr()` (String String):**\n    *   **Purpose:** Finds the first occurrence of a substring (the \"needle\") within another string (the \"haystack\").\n    *   **Syntax:** `char *strstr(const char *haystack, const char *needle);`\n    *   **Description:** It searches for the first occurrence of the null-terminated string `needle` within the null-terminated string `haystack`. If `needle` is found, it returns a pointer to the first character of the found substring within `haystack`. If `needle` is not found, it returns `NULL`. If `needle` is an empty string, it returns `haystack`.\n\n4.  **`strtok()` (String Tokenizer):**\n    *   **Purpose:** Breaks a string into a sequence of tokens (sub-strings), using a set of delimiter characters.\n    *   **Syntax:** `char *strtok(char *str, const char *delimiter);`\n    *   **Description:**\n        *   **First Call:** When called with a non-`NULL` `str`, `strtok()` finds the first token in `str` that is not part of the `delimiter` set. It then replaces the first delimiter character after the token with a null terminator (`\\0`) and returns a pointer to the token.\n        *   **Subsequent Calls:** To continue tokenizing the *same* string, subsequent calls to `strtok()` should pass `NULL` as the `str` argument. `strtok()` maintains an internal static pointer to keep track of its position in the string.\n        *   It returns `NULL` when no more tokens are found.\n    *   **Important Note:** `strtok()` modifies the original string by inserting null terminators. It is also not re-entrant and generally not thread-safe. For multi-threaded or re-entrant requirements, `strtok_r()` (POSIX standard) or a manual tokenization approach is often preferred.",
            "answer_source": "generated",
            "chapter": "Unit 3: Built-inString Functions: atoi, strlen, strcat, strcmp, String Functions: sprint, sscanf, strrev, strcpy, strstr, strtok"
        },
        {
            "question_number": "14.",
            "question_text": "How an array construction is done for real-time application and what are the common programming errors in it?",
            "marks": 4,
            "answer": "**Array Construction for Real-Time Applications:**\n\nArrays are crucial in real-time applications for managing fixed collections of data requiring fast, direct access. Their construction emphasizes predictability and efficiency.\n\n1.  **Declaration and Initialization:**\n    *   **Static/Global Arrays:** In hard real-time systems, arrays are often declared globally or as static local variables. This avoids the non-deterministic timing and potential overhead of dynamic memory allocation (`malloc`, `calloc`), ensuring memory is reserved at compile time. Example: `int sensor_data[128];`\n    *   **Fixed Size:** Sizes are typically determined at compile time using constants (`#define`) to guarantee memory allocation and avoid runtime surprises. Example: `char packet_buffer[BUFFER_SIZE];`\n    *   **Initialization:** For safety and predictability, arrays are often explicitly initialized to zero or a known state upon declaration. Example: `int status_flags[10] = {0};`\n2.  **Multidimensional Arrays:** Used for data like matrices, image frames, or grid maps. `float image_frame[120][160];`\n3.  **Memory Layout:** Arrays provide contiguous memory, which is ideal for cache performance and efficient processing (e.g., DMA transfers). This contiguous nature is exploited for algorithms requiring fast sequential access.\n\n**Common Programming Errors with Arrays:**\n\n1.  **Array Index Out of Bounds:**\n    *   **Problem:** Attempting to access an element at an index outside the array's defined range (e.g., `arr[size]` for an array of size `size` which is indexed `0` to `size-1`). This is the most common and dangerous error.\n    *   **Consequence:** Undefined behavior, leading to memory corruption, crashes, or unpredictable program state.\n    *   **Prevention:** Always verify loop conditions and direct index accesses. Use symbolic constants for array sizes. `for (i=0; i < SIZE; i++)` is safer than `i <= SIZE`.\n\n2.  **Buffer Overflows/Underflows:**\n    *   **Problem:** Similar to out-of-bounds, specifically when copying data into a character array (string) without sufficient space. An overflow writes past the allocated memory; an underflow reads/writes before the allocated memory (less common).\n    *   **Consequence:** Security vulnerabilities, system crashes.\n    *   **Prevention:** Use size-constrained functions like `strncpy`, `fgets`, or ensure the destination buffer has enough space for the source data plus a null terminator for strings.\n\n3.  **Off-by-One Errors:**\n    *   **Problem:** Loops or calculations that iterate one too many or one too few times. This often results in out-of-bounds access or incomplete data processing.\n    *   **Consequence:** Incorrect results, program logic errors.\n    *   **Prevention:** Carefully check loop conditions (e.g., `i < N` vs. `i <= N`), starting and ending values of indices.\n\n4.  **Not Null-Terminating Strings:**\n    *   **Problem:** Character arrays used as strings must end with a null character (`\\0`). If missing, string manipulation functions (`strlen`, `printf(\"%s\")`, `strcpy`) will read past the allocated memory.\n    *   **Consequence:** Undefined behavior, crashes, reading garbage data.\n    *   **Prevention:** Always allocate `size+1` bytes for strings of `size` characters. Ensure string functions correctly add the null terminator, or add it manually (e.g., `buffer[index] = '\\0';`).\n\n5.  **Confusing Array Name with Modifiable Pointer:**\n    *   **Problem:** An array name acts as a constant pointer to its first element; its address cannot be changed (e.g., `array1 = array2;` is illegal).\n    *   **Consequence:** Compile-time error.\n    *   **Prevention:** To copy array contents, iterate element by element or use `memcpy`/`strcpy`.",
            "answer_source": "generated",
            "chapter": "Unit 2: Introduction to Arrays -One Dimensional (1D) Array Declaration and initialization; Accessing, Indexing and operations with 1D Arrays; Initializing and Accessing 2D Array"
        },
        {
            "question_number": "15.",
            "question_text": "Compare the call by value and reference in function call with an example.",
            "marks": 4,
            "answer": "**Call by Value vs. Call by Reference in C**\n\nIn C programming, arguments can be passed to functions in two primary ways: Call by Value and Call by Reference. The method chosen determines whether the function can modify the original variables in the calling scope.\n\n**1. Call by Value:**\n*   **Mechanism:** When you pass arguments by value, a *copy* of the actual argument's value is created and passed to the function's formal parameters. The function operates on these copies.\n*   **Modification:** Any changes made to the formal parameters inside the function affect only these local copies; the original variables in the calling function remain unchanged.\n*   **Memory:** The actual arguments and formal parameters reside in distinct memory locations.\n*   **Use Case:** Best when the function only needs to read the values and does not need to alter the original data.\n\n**Example (Call by Value):**\n```c\n#include <stdio.h>\n\nvoid increment_by_value(int num) {\n    num = num + 10; // 'num' is a local copy of 'x'\n    printf(\"Inside function (by value): num = %d\\n\", num);\n}\n\nint main() {\n    int x = 5;\n    printf(\"Before function call: x = %d\\n\", x);\n    increment_by_value(x); // Pass the value of x\n    printf(\"After function call: x = %d\\n\", x); // x remains 5\n    return 0;\n}\n```\n\n**2. Call by Reference:**\n*   **Mechanism:** When you pass arguments by reference, the *memory address* (a pointer) of the actual argument is passed to the function. The formal parameter in the function is a pointer that stores this address.\n*   **Modification:** By dereferencing the pointer inside the function, you can directly access and modify the original variable at its memory location in the calling function.\n*   **Memory:** Both the actual argument and the formal parameter (pointer) refer to the *same* memory location for the variable being modified.\n*   **Use Case:** Essential when the function needs to modify the original variables, or when passing large data structures (like arrays) efficiently without incurring the overhead of copying them.\n\n**Example (Call by Reference):**\n```c\n#include <stdio.h>\n\nvoid increment_by_reference(int *ptr_num) {\n    *ptr_num = *ptr_num + 10; // Dereference pointer to modify original value\n    printf(\"Inside function (by reference): *ptr_num = %d\\n\", *ptr_num);\n}\n\nint main() {\n    int y = 5;\n    printf(\"Before function call: y = %d\\n\", y);\n    increment_by_reference(&y); // Pass the address of y\n    printf(\"After function call: y = %d\\n\", y); // y becomes 15\n    return 0;\n}\n```\n\n**Summary Comparison:**\n\n| Feature           | Call by Value                                | Call by Reference                                  |\n| :---------------- | :------------------------------------------- | :------------------------------------------------- |\n| **Argument Passed** | A copy of the actual value.                  | The memory address of the actual variable.         |\n| **Modification**  | Changes to parameters do not affect originals. | Changes to parameters affect originals.            |\n| **Memory**        | Separate memory for actual & formal params.  | Formal parameter points to actual argument's memory. |\n| **Overhead**      | Can be higher for large data (copying).      | Lower for large data (only address copied).        |\n| **Safety**        | Original data is implicitly protected.       | Original data can be unintentionally modified.     |",
            "answer_source": "generated",
            "chapter": "Unit 3: Call by Value, Call by Reference; Function with and without Arguments; Function with and without return values"
        },
        {
            "question_number": "16. (a)",
            "question_text": "Enumerate and compare for loop syntax with while loop using an example in C language. Discuss the common problems in loops.",
            "marks": 12,
            "answer": "**Comparison of `for` Loop and `while` Loop in C**\n\nBoth `for` and `while` loops are fundamental control structures in C used to execute a block of code repeatedly. While they can often achieve the same results, their syntax and typical use cases differ.\n\n**1. `for` Loop**\n*   **Syntax:**\n    ```c\n    for (initialization; condition; increment/decrement) {\n        // Code to be executed repeatedly\n    }\n    ```\n*   **Description:** The `for` loop is ideal when the number of iterations is known or can be easily determined before the loop begins. Its structure neatly bundles the three essential parts of a counter-controlled loop:\n    1.  **Initialization:** Executed once at the beginning to set up the loop control variable.\n    2.  **Condition:** Evaluated before each iteration. If true, the loop body executes. If false, the loop terminates.\n    3.  **Increment/Decrement:** Executed after each iteration of the loop body to update the loop control variable.\n*   **Example:** Printing numbers from 1 to 5.\n    ```c\n    #include <stdio.h>\n\n    int main() {\n        printf(\"Using for loop:\\n\");\n        for (int i = 1; i <= 5; i++) {\n            printf(\"%d \", i);\n        }\n        printf(\"\\n\");\n        return 0;\n    }\n    ```\n    *Output: 1 2 3 4 5*\n\n**2. `while` Loop**\n*   **Syntax:**\n    ```c\n    while (condition) {\n        // Code to be executed repeatedly\n        // Increment/decrement or other condition-altering statements here\n    }\n    ```\n*   **Description:** The `while` loop is best suited when the number of iterations is not known beforehand, and the loop continues as long as a specific condition remains true. The initialization and increment/decrement of the loop control variable must be explicitly handled outside and inside the loop body, respectively.\n*   **Example:** Printing numbers from 1 to 5.\n    ```c\n    #include <stdio.h>\n\n    int main() {\n        printf(\"Using while loop:\\n\");\n        int i = 1; // Initialization\n        while (i <= 5) { // Condition\n            printf(\"%d \", i);\n            i++; // Increment\n        }\n        printf(\"\\n\");\n        return 0;\n    }\n    ```\n    *Output: 1 2 3 4 5*\n\n**Key Differences:**\n\n| Feature           | `for` Loop                                   | `while` Loop                                        |\n| :---------------- | :------------------------------------------- | :-------------------------------------------------- |\n| **Structure**     | Initialization, condition, and update are declared together in the loop header. | Only the condition is in the header; initialization and update are separate. |\n| **Typical Use**   | When the number of iterations is known in advance (e.g., iterating through an array). | When the number of iterations is unknown and depends on a condition (e.g., reading until EOF, user input validation). |\n| **Conciseness**   | More compact for simple counting loops.      | Can be more flexible for complex termination logic. |\n| **Readability**   | All loop control elements are visible at a glance. | Control elements can be scattered, potentially affecting readability. |\n| **Flexibility**   | Highly flexible, though not always as intuitive for non-counter-controlled loops. | Clearer for condition-based iteration where the loop counter is not the primary control. |\n\n**Common Problems in Loops:**\n\n1.  **Infinite Loops:**\n    *   **Description:** A loop that runs endlessly because its termination condition never becomes false. This can hang the program.\n    *   **Causes:** Forgetting to update the loop control variable, an incorrect condition that always evaluates to true, or an update that prevents the condition from ever becoming false.\n    *   **Example:** `while (1) { /* ... */ }` without a `break`, or `int i = 0; while (i < 5) { /* ... */ }` where `i` is never incremented.\n    *   **Prevention:** Always ensure there's a mechanism within the loop body or condition that will eventually cause the condition to fail.\n\n2.  **Off-by-One Errors:**\n    *   **Description:** The loop executes one more or one less time than intended. This is a common logical error, especially with array indexing.\n    *   **Causes:** Incorrect use of relational operators (`<` vs. `<=`, `>` vs. `>=`) in the loop condition, or incorrect initial/final values for loop counters.\n    *   **Example:** `for (int i = 0; i <= N; i++)` when processing an array of size `N` (indices `0` to `N-1`), leading to an out-of-bounds access at `arr[N]`.\n    *   **Prevention:** Carefully verify loop boundaries and starting/ending conditions. For 0-indexed arrays of size `N`, loop from `0` up to (but not including) `N`.\n\n3.  **Incorrect Loop Termination:**\n    *   **Description:** The loop terminates too early (missing necessary iterations) or too late (performing redundant work or causing errors).\n    *   **Causes:** Misplaced `break` or `continue` statements, complex conditions that don't cover all cases, or incorrect handling of input streams (e.g., not consuming newline characters).\n    *   **Prevention:** Test with various inputs, including edge cases. Use debugging tools to trace loop variable values.\n\n4.  **Inefficient Loop Operations:**\n    *   **Description:** The loop performs computations unnecessarily in each iteration, leading to poor performance, especially in critical sections or for large datasets.\n    *   **Causes:** Re-calculating values that remain constant throughout the loop, or performing I/O operations inside a tight loop when it could be done less frequently.\n    *   **Prevention:** Optimize loop bodies. Move invariant computations outside the loop. Select appropriate algorithms and data structures.\n\n5.  **Side Effects in Loop Conditions:**\n    *   **Description:** Modifying variables within the loop condition itself can make the loop's behavior hard to predict and debug, especially with complex expressions and operator precedence.\n    *   **Example:** `while (i++ < 10 && some_func() > 0)`.\n    *   **Prevention:** Generally, keep loop conditions focused solely on evaluation. Perform side effects (like increments) explicitly within the loop body to improve clarity and maintainability.",
            "answer_source": "generated",
            "chapter": "Unit 2: Looping Control Statements: for, while, do.while, nested for, nested while"
        },
        {
            "question_number": "16. (b)",
            "question_text": "Write a C program to find maximum and minimum between two numbers using functions",
            "marks": 12,
            "answer": "```c\n#include <stdio.h>\n\n// Function to find the maximum of two integers\n// Takes two integers by value and returns the larger one.\nint find_maximum(int num1, int num2) {\n    if (num1 > num2) {\n        return num1;\n    } else {\n        return num2;\n    }\n}\n\n// Function to find the minimum of two integers\n// Takes two integers by value and returns the smaller one.\nint find_minimum(int num1, int num2) {\n    if (num1 < num2) {\n        return num1;\n    } else {\n        return num2;\n    }\n}\n\nint main() {\n    int number1, number2;\n    int max_val, min_val;\n\n    // Get input from the user\n    printf(\"Enter the first number: \");\n    scanf(\"%d\", &number1);\n\n    printf(\"Enter the second number: \");\n    scanf(\"%d\", &number2);\n\n    // Call the functions to find maximum and minimum\n    max_val = find_maximum(number1, number2);\n    min_val = find_minimum(number1, number2);\n\n    // Display the results\n    printf(\"\\nThe maximum number is: %d\\n\", max_val);\n    printf(\"The minimum number is: %d\\n\", min_val);\n\n    return 0;\n}\n```",
            "answer_source": "generated",
            "chapter": "Unit 3: Function prototype declaration, function definition; Function with and without Arguments; Function with and without return values"
        },
        {
            "question_number": "17. (a)",
            "question_text": "Write a C program to compute addition of two matrices.",
            "marks": 12,
            "answer": "```c\n#include <stdio.h>\n\n// Define the dimensions of the matrices\n#define ROWS 3\n#define COLS 3\n\n// Function to input elements of a matrix\nvoid input_matrix(int matrix[ROWS][COLS], const char *name) {\n    printf(\"Enter elements of matrix %s (%dx%d):\\n\", name, ROWS, COLS);\n    for (int i = 0; i < ROWS; i++) {\n        for (int j = 0; j < COLS; j++) {\n            printf(\"Enter element [%d][%d]: \", i, j);\n            scanf(\"%d\", &matrix[i][j]);\n        }\n    }\n}\n\n// Function to print a matrix\nvoid print_matrix(int matrix[ROWS][COLS], const char *name) {\n    printf(\"\\nMatrix %s:\\n\", name);\n    for (int i = 0; i < ROWS; i++) {\n        for (int j = 0; j < COLS; j++) {\n            printf(\"%d\\t\", matrix[i][j]); // \\t for tab spacing\n        }\n        printf(\"\\n\"); // New line after each row\n    }\n}\n\n// Function to add two matrices and store the result in a third matrix\nvoid add_matrices(int matrix1[ROWS][COLS], int matrix2[ROWS][COLS], int result_matrix[ROWS][COLS]) {\n    printf(\"\\nPerforming matrix addition...\\n\");\n    for (int i = 0; i < ROWS; i++) {\n        for (int j = 0; j < COLS; j++) {\n            result_matrix[i][j] = matrix1[i][j] + matrix2[i][j];\n        }\n    }\n}\n\nint main() {\n    int mat1[ROWS][COLS];    // First matrix\n    int mat2[ROWS][COLS];    // Second matrix\n    int sum_mat[ROWS][COLS]; // Resultant matrix for sum\n\n    // Input elements for the first matrix\n    input_matrix(mat1, \"A\");\n\n    // Input elements for the second matrix\n    input_matrix(mat2, \"B\");\n\n    // Add the two matrices\n    add_matrices(mat1, mat2, sum_mat);\n\n    // Print all three matrices\n    print_matrix(mat1, \"A\");\n    print_matrix(mat2, \"B\");\n    print_matrix(sum_mat, \"Sum (A + B)\");\n\n    return 0;\n}\n```",
            "answer_source": "generated",
            "chapter": "Unit 2: Initializing and Accessing 2D Array, Array Programs \u2013 2D, Looping Control Statements: nested for; Unit 3: Passing Array to Function"
        },
        {
            "question_number": "17. (b)",
            "question_text": "Write a C program to convert given uppercase string to lowercase and viceversa.",
            "marks": 12,
            "answer": "```c\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h> // Required for toupper() and tolower()\n\n// Function to convert a string to lowercase\n// Modifies the string in-place\nvoid to_lowercase(char *str) {\n    for (int i = 0; str[i] != '\\0'; i++) {\n        str[i] = tolower((unsigned char)str[i]);\n    }\n}\n\n// Function to convert a string to uppercase\n// Modifies the string in-place\nvoid to_uppercase(char *str) {\n    for (int i = 0; str[i] != '\\0'; i++) {\n        str[i] = toupper((unsigned char)str[i]);\n    }\n}\n\nint main() {\n    char original_str[100]; // Buffer to hold the original string\n    char str_for_lower[100]; // Buffer for lowercase conversion\n    char str_for_upper[100]; // Buffer for uppercase conversion\n\n    printf(\"Enter a string (max 99 characters): \");\n    fgets(original_str, sizeof(original_str), stdin); // Read input including spaces\n\n    // Remove trailing newline character that fgets might read\n    original_str[strcspn(original_str, \"\\n\")] = 0;\n\n    // Copy the original string to buffers for conversions\n    strcpy(str_for_lower, original_str);\n    strcpy(str_for_upper, original_str);\n\n    printf(\"\\nOriginal string: %s\\n\", original_str);\n\n    // Convert to lowercase and print\n    to_lowercase(str_for_lower);\n    printf(\"Lowercase string: %s\\n\", str_for_lower);\n\n    // Convert to uppercase and print\n    to_uppercase(str_for_upper);\n    printf(\"Uppercase string: %s\\n\", str_for_upper);\n\n    return 0;\n}\n```",
            "answer_source": "generated",
            "chapter": "Unit 3: String Basics; Operations on Strings; String Functions: gets(), puts(), getchar(),putchar(), printf(); Built-inString Functions: strlen, strcpy"
        }
    ]
}