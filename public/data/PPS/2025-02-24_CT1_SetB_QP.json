{
  "paper_title": "Programming For Problem Solving (SRM Institute of Science and Technology)",
  "source": "2025-02-24 CT1 SetB",
  "questions": [
    {
      "question_number": "1",
      "question_text": "Differentiate NULL pointer and VOID pointer.",
      "marks": 2,
      "answer": "**NULL Pointer:**\nA NULL pointer is a pointer that points to nothing. It is a special reserved value (usually `0` or `(void*)0`) which indicates that the pointer does not point to any valid memory address. It is defined in `stdio.h` or `stdlib.h` as a macro `NULL`. NULL pointers are often used to initialize pointers, to indicate that a pointer variable is not currently pointing to any object, or as an error indicator from functions that return pointers.\n\n**VOID Pointer (Generic Pointer):**\nA VOID pointer (declared as `void *`) is a generic pointer that can hold the address of any data type. It is also known as a generic pointer because it is not associated with any specific data type. A `void *` pointer can be assigned an address of any type of variable, but it cannot be directly dereferenced. To dereference a `void *` pointer, it must first be type-casted to a specific data type pointer. Void pointers are often used in functions that handle memory for various data types, such as `malloc()`, `calloc()`, and `memcpy()`.\n\n**Key Differences:**\n\n| Feature             | NULL Pointer                                      | VOID Pointer                                               |\n| :------------------ | :------------------------------------------------ | :--------------------------------------------------------- |\n| **Purpose**         | Indicates that a pointer points to no valid object. | Can point to an object of *any* data type.                  |\n| **Type Specificity**| Not type-specific in its value (0/NULL), but contextually linked to a type. | Is a generic pointer; not associated with a specific data type. |\n| **Dereferencing**   | Cannot be dereferenced (points to nothing).       | Cannot be dereferenced directly; requires type-casting.    |\n| **Pointer Arithmetic**| Not applicable.                                 | Not allowed directly; requires type-casting to a specific type first. |\n| **Initialization**  | Often used for initializing pointers to a known 'empty' state. | Can be assigned addresses of any type without explicit casting. |\n| **Example**         | `int *ptr = NULL;`                                | `int x = 10; void *vptr = &x; int *iptr = (int *)vptr;` |\n\nIn summary, a NULL pointer signifies the absence of an address, while a `void` pointer signifies the presence of an address whose type is currently unknown or generic.",
      "answer_source": "generated",
      "chapter": "Unit 2: Conditional Control -Statements :Simple if, if...else"
    },
    {
      "question_number": "2a",
      "question_text": "What is the expected output of below codes?\na)\n#include <stdio.h>\nint main()\n{\n    int i;\n    int arr[5] = {1};\n    for (i = 0; i < 5; j++)\n    {\n        printf(\"%d \", arr[i]):\n    }\n    return 0;\n}\n",
      "marks": 2,
      "answer": "The provided code snippet contains a typo in the `for` loop's increment expression (`j++`) and a syntax error in `printf` (`:` instead of `;`). Assuming these are typos and the intent was `i++` for the loop control and `printf(\"%d \", arr[i]);`:\n\n**Corrected Code (assumed intent):**\n```c\n#include <stdio.h>\nint main()\n{\n    int i;\n    int arr[5] = {1}; // Initializes arr as {1, 0, 0, 0, 0}\n    for (i = 0; i < 5; i++) // Assuming j++ was a typo and should be i++\n    {\n        printf(\"%d \", arr[i]); // Assuming : was a typo and should be ;\n    }\n    return 0;\n}\n```\n\n**Explanation:**\n1.  `int arr[5] = {1};` initializes the first element `arr[0]` to 1. All remaining elements (`arr[1]` to `arr[4]`) are automatically initialized to 0. So, `arr` becomes `{1, 0, 0, 0, 0}`.\n2.  The `for` loop iterates from `i = 0` to `i = 4` (inclusive).\n3.  In each iteration, `printf(\"%d \", arr[i]);` prints the current element of the array followed by a space.\n\n**Expected Output:**\n```text\n1 0 0 0 0 \n```\n\nIf the typo `j++` is taken literally, and `j` is undeclared, the program would result in a compilation error. If `j` were declared but not initialized, it would lead to undefined behavior, potentially an infinite loop or crash. Given the context of a question paper, assuming `i++` is the most common interpretation for such a loop structure.",
      "answer_source": "generated",
      "chapter": "Unit 2: Conditional Control -Statements :Simple if, if...else"
    },
    {
      "question_number": "2b",
      "question_text": "What is the expected output of below codes?\nb)\nvoid main()\n{\n    int a[3] = {1,2,3};\n    int *p = a;\n    for(int j=0; j<3;i++)\n    {\n        Printf(\"%d\", *p);\n        P++;\n    }\n    return 0;\n}\n",
      "marks": 2,
      "answer": "The provided code snippet contains several typos:\n1.  `void main()`: While accepted by some compilers, `int main()` is standard C.\n2.  `for(int j=0; j<3;i++)`: The increment `i++` refers to an undeclared `i`. It should likely be `j++`.\n3.  `Printf`: Should be `printf` (lowercase 'p').\n4.  `P++`: Should be `p++` (lowercase 'p').\n5.  `return 0;` is outside the `main` function's body or belongs inside the `main` function (if it were `int main()`). In `void main()`, `return 0;` is typically not used, or simply `return;`.\n\n**Corrected Code (assumed intent):**\n```c\n#include <stdio.h> // Include for printf\n\nint main() // Using standard int main()\n{\n    int a[3] = {1,2,3};\n    int *p = a; // p points to the first element of array 'a'\n\n    for(int j=0; j<3; j++) // Corrected increment to j++\n    {\n        printf(\"%d\", *p); // Corrected Printf to printf\n        p++; // Corrected P++ to p++\n    }\n    return 0;\n}\n```\n\n**Explanation:**\n1.  `int a[3] = {1,2,3};` initializes an integer array `a` with values 1, 2, and 3.\n2.  `int *p = a;` declares an integer pointer `p` and initializes it with the address of the first element of array `a` (i.e., `a[0]`). So, `*p` initially holds the value 1.\n3.  The `for` loop iterates three times (for `j = 0, 1, 2`).\n    *   **Iteration 1 (j=0):** `p` points to `a[0]`. `printf(\"%d\", *p)` prints `1`. `p++` increments `p` to point to `a[1]`. (Value 2)\n    *   **Iteration 2 (j=1):** `p` points to `a[1]`. `printf(\"%d\", *p)` prints `2`. `p++` increments `p` to point to `a[2]`. (Value 3)\n    *   **Iteration 3 (j=2):** `p` points to `a[2]`. `printf(\"%d\", *p)` prints `3`. `p++` increments `p` to point to `a[3]` (which is past the end of the array, but not dereferenced again in the loop).\n\nThe numbers are printed consecutively without any spaces or newlines because `%d` is used without any formatting characters like ` ` or `\\n`.\n\n**Expected Output:**\n```text\n123\n```",
      "answer_source": "generated",
      "chapter": "Unit 2: Conditional Control -Statements :Simple if, if...else"
    },
    {
      "question_number": "3",
      "question_text": "Contrast the function printf and sprintf in C.",
      "marks": 2,
      "answer": "The `printf` and `sprintf` functions in C are both used for formatted output, but they differ in their destination:\n\n**1. `printf()` (Print Formatted):**\n*   **Purpose:** `printf()` is used to write formatted output to the standard output stream, which is typically the console (terminal).\n*   **Syntax:** `int printf(const char *format, ...);`\n*   **Return Value:** Returns the number of characters printed, or a negative value if an output error occurs.\n*   **Behavior:** It takes a format string and a variable number of arguments, formats them according to the format specifiers, and displays the result directly on the screen.\n*   **Example:**\n    ```c\n    #include <stdio.h>\n    int main() {\n        int num = 10;\n        char name[] = \"Alice\";\n        printf(\"Hello, %s! Your number is %d.\\n\", name, num);\n        return 0;\n    }\n    // Output: Hello, Alice! Your number is 10.\n    ```\n\n**2. `sprintf()` (String Print Formatted):**\n*   **Purpose:** `sprintf()` is used to write formatted output to a character array (string buffer) instead of the console.\n*   **Syntax:** `int sprintf(char *str, const char *format, ...);`\n*   **Return Value:** Returns the number of characters written into the array `str` (excluding the null terminator), or a negative value if an error occurred.\n*   **Behavior:** It takes a destination character array `str`, a format string, and a variable number of arguments. It formats the arguments and stores the resulting string into `str`, automatically appending a null terminator (`\\0`).\n*   **Example:**\n    ```c\n    #include <stdio.h>\n    int main() {\n        char buffer[100];\n        int num = 25;\n        char item[] = \"pens\";\n        sprintf(buffer, \"We have %d %s.\\n\", num, item);\n        printf(\"Buffered string: %s\", buffer);\n        return 0;\n    }\n    // Output: Buffered string: We have 25 pens.\n    ```\n\n**Key Differences in Tabular Form:**\n\n| Feature           | `printf()`                                          | `sprintf()`                                            |\n| :---------------- | :-------------------------------------------------- | :----------------------------------------------------- |\n| **Output Destination** | Standard output stream (console/terminal).          | A character array (string buffer) in memory.            |\n| **First Argument**| Format string.                                      | Destination character array.                             |\n| **Buffer Handling**| No explicit buffer management needed; system handles output. | Requires a pre-allocated buffer; user responsible for buffer size. |\n| **Primary Use**   | Displaying information directly to the user.        | Creating/formatting strings for later use (e.g., logging, file writing, parsing). |\n| **Return Value**  | Number of characters printed to stdout.             | Number of characters written to the string buffer (excluding null terminator). |\n| **Risk**          | Generally safe regarding buffer overflows.           | High risk of buffer overflow if the buffer `str` is not large enough for the formatted output, potentially leading to security vulnerabilities or crashes. (Safer alternatives like `snprintf` exist for bounded writing). |\n\nIn essence, `printf` is for direct display, while `sprintf` is for string construction.",
      "answer_source": "generated",
      "chapter": "Unit 3: String Basics - String Declaration and Initialization"
    },
    {
      "question_number": "4",
      "question_text": "Write a C Program to find a substring from the main string using built in function.",
      "marks": 2,
      "answer": "To find a substring from a main string in C, we can use the built-in function `strstr()` from the `string.h` library.\n\n**`strstr()` Function:**\n*   **Syntax:** `char *strstr(const char *haystack, const char *needle);`\n*   **Purpose:** It searches for the first occurrence of the substring `needle` within the string `haystack`.\n*   **Return Value:**\n    *   If `needle` is found, it returns a pointer to the first character of the first occurrence of `needle` in `haystack`.\n    *   If `needle` is not found, it returns `NULL`.\n    *   If `needle` is an empty string, it returns `haystack`.\n\n**C Program to find a substring:**\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char mainString[100];\n    char subString[50];\n    char *result;\n\n    // Get the main string from the user\n    printf(\"Enter the main string: \");\n    fgets(mainString, sizeof(mainString), stdin);\n    mainString[strcspn(mainString, \"\\n\")] = 0; // Remove trailing newline\n\n    // Get the substring to find from the user\n    printf(\"Enter the substring to find: \");\n    fgets(subString, sizeof(subString), stdin);\n    subString[strcspn(subString, \"\\n\")] = 0; // Remove trailing newline\n\n    // Use strstr() to find the substring\n    result = strstr(mainString, subString);\n\n    // Check if the substring was found\n    if (result != NULL) {\n        printf(\"\\\"%s\\\" found in \\\"%s\\\" at position: %ld\\n\", subString, mainString, result - mainString);\n        printf(\"The remaining part of the string from the first occurrence is: \\\"%s\\\"\\n\", result);\n    } else {\n        printf(\"\\\"%s\\\" not found in \\\"%s\\\"\\n\", subString, mainString);\n    }\n\n    return 0;\n}\n```\n\n**Explanation:**\n1.  **Includes:** `stdio.h` for input/output and `string.h` for `strstr()` and `strcspn()`.\n2.  **Input:** The program prompts the user to enter the main string and the substring. `fgets()` is used for safer input, and `strcspn()` is used to remove the newline character that `fgets()` typically includes.\n3.  **`strstr()` Call:** `strstr(mainString, subString)` is called. If `subString` is found within `mainString`, `result` will point to the location where it starts; otherwise, `result` will be `NULL`.\n4.  **Output:** Based on the value of `result`, the program informs the user whether the substring was found. If found, it also calculates and prints the starting position (index) of the substring using pointer arithmetic (`result - mainString`) and the remaining part of the string from that point.",
      "answer_source": "generated",
      "chapter": "Unit 3: String Basics - String Declaration and Initialization"
    },
    {
      "question_number": "5a",
      "question_text": "What are pointers? How to use pointers? Explain the declaration of pointers and pointer to pointer with examples.",
      "marks": 8,
      "answer": "**What are Pointers?**\nIn C, a pointer is a variable that stores the memory address of another variable. Instead of storing a direct value, it stores the location (address) where a value is stored in the computer's memory. Pointers are fundamental in C for various reasons, including dynamic memory allocation, efficient array and string manipulation, passing arguments by reference to functions, and building complex data structures like linked lists and trees.\n\n**How to Use Pointers:**\nUsing pointers involves several key operations:\n1.  **Declaration:** Declaring a pointer variable.\n2.  **Initialization:** Assigning a memory address to the pointer.\n3.  **Address-of Operator (`&`):** Used to get the memory address of a variable.\n4.  **Dereference Operator (`*`):** Used to access the value stored at the memory address pointed to by a pointer.\n\n**Declaration of Pointers:**\nA pointer variable is declared by placing an asterisk (`*`) between the data type and the pointer variable name. The data type specifies the type of data that the pointer will point to.\n\n**Syntax:** `data_type *pointer_name;`\n\n**Examples:**\n```c\nint *ptr_int;         // Declares a pointer to an integer\nchar *ptr_char;       // Declares a pointer to a character\nfloat *ptr_float;     // Declares a pointer to a float\ndouble *ptr_double;    // Declares a pointer to a double\n```\n\n**Example of Pointer Usage:**\n```c\n#include <stdio.h>\n\nint main() {\n    int num = 10;        // Declare an integer variable\n    int *ptr;            // Declare an integer pointer\n\n    ptr = &num;          // Initialize ptr with the address of num (using & operator)\n\n    printf(\"Value of num: %d\\n\", num);          // Output: 10\n    printf(\"Address of num: %p\\n\", &num);        // Output: (e.g., 0x7ffee234a5d4)\n    printf(\"Value of ptr (address of num): %p\\n\", ptr); // Output: (e.g., 0x7ffee234a5d4)\n    printf(\"Value at address pointed to by ptr: %d\\n\", *ptr); // Output: 10 (using * dereference operator)\n\n    *ptr = 20;           // Change the value of num through the pointer\n    printf(\"New value of num: %d\\n\", num);      // Output: 20\n\n    return 0;\n}\n```\n\n**Pointer to Pointer (Double Pointer):**\nA pointer to a pointer (also known as a double pointer or multiple indirection) is a variable that stores the memory address of another pointer variable. It allows you to indirectly access and modify the value of the original variable through multiple levels of indirection.\n\n**Declaration:**\nTo declare a pointer to a pointer, you use two asterisks (`**`).\n\n**Syntax:** `data_type **ptr_to_ptr_name;`\n\n**Example of Pointer to Pointer Usage:**\n```c\n#include <stdio.h>\n\nint main() {\n    int val = 100;           // An integer variable\n    int *ptr1;               // A pointer to an integer\n    int **ptr2;              // A pointer to a pointer to an integer\n\n    ptr1 = &val;             // ptr1 stores the address of val\n    ptr2 = &ptr1;            // ptr2 stores the address of ptr1\n\n    printf(\"Value of val: %d\\n\", val);             // Output: 100\n    printf(\"Address of val: %p\\n\", &val);           // (e.g., 0x7ffee234a5d4)\n\n    printf(\"Value of ptr1 (address of val): %p\\n\", ptr1); // (e.g., 0x7ffee234a5d4)\n    printf(\"Address of ptr1: %p\\n\", &ptr1);         // (e.g., 0x7ffee234a5e0)\n    printf(\"Value at address pointed by ptr1 (*ptr1): %d\\n\", *ptr1); // Output: 100\n\n    printf(\"Value of ptr2 (address of ptr1): %p\\n\", ptr2); // (e.g., 0x7ffee234a5e0)\n    printf(\"Address of ptr2: %p\\n\", &ptr2);         // (e.g., 0x7ffee234a5e8)\n\n    // Accessing val through ptr2:\n    printf(\"Value at address pointed by ptr2 (*ptr2 is ptr1's value): %p\\n\", *ptr2); // (e.g., 0x7ffee234a5d4)\n    printf(\"Value at address pointed by *ptr2 (**ptr2 is val): %d\\n\", **ptr2);   // Output: 100\n\n    // Modifying val through ptr2:\n    **ptr2 = 200;\n    printf(\"New value of val after **ptr2 = 200: %d\\n\", val); // Output: 200\n\n    return 0;\n}\n```\nDouble pointers are useful in scenarios where you need to modify the pointer itself within a function (e.g., changing where a pointer points), rather than just the data it points to, or when working with arrays of pointers.",
      "answer_source": "generated",
      "chapter": "Unit 2: Conditional Control -Statements :Simple if, if...else"
    },
    {
      "question_number": "5b",
      "question_text": "Write a C program that performs matrix multiplication on two matrices of size r x c. The program should take input for the number of rows and columns in the matrices and the elements of the matrices from the user. The program uses nested for loops to perform the matrix multiplication and stores the result in a new matrix \"m\". The program should then print the result matrix on the screen.",
      "marks": 8,
      "answer": "**Matrix Multiplication Program in C**\n\nMatrix multiplication requires specific conditions: the number of columns in the first matrix must be equal to the number of rows in the second matrix. If a matrix A is of size `r1 x c1` and matrix B is of size `r2 x c2`, then for multiplication to be possible, `c1` must be equal to `r2`. The resulting matrix C will have dimensions `r1 x c2`.\n\n**Algorithm:**\n1.  Declare three 2D arrays (matrices): `matrixA`, `matrixB`, and `resultMatrix`.\n2.  Get the dimensions (rows and columns) for `matrixA` (`r1, c1`) and `matrixB` (`r2, c2`) from the user.\n3.  Check if `c1 == r2`. If not, print an error message and exit.\n4.  Read the elements of `matrixA` from the user using nested loops.\n5.  Read the elements of `matrixB` from the user using nested loops.\n6.  Initialize all elements of `resultMatrix` to 0.\n7.  Perform matrix multiplication using three nested loops:\n    *   Outer loop for `resultMatrix` rows (`i` from 0 to `r1-1`).\n    *   Middle loop for `resultMatrix` columns (`j` from 0 to `c2-1`).\n    *   Inner loop for summation (`k` from 0 to `c1-1`):\n        `resultMatrix[i][j] += matrixA[i][k] * matrixB[k][j];`\n8.  Print the `resultMatrix` on the screen using nested loops.\n\n**C Program:**\n\n```c\n#include <stdio.h>\n\n#define MAX_SIZE 10 // Define a maximum size for matrices\n\nint main() {\n    int matrixA[MAX_SIZE][MAX_SIZE];\n    int matrixB[MAX_SIZE][MAX_SIZE];\n    int resultMatrix[MAX_SIZE][MAX_SIZE];\n    int r1, c1, r2, c2;\n    int i, j, k;\n\n    // Input dimensions for Matrix A\n    printf(\"Enter the number of rows for Matrix A: \");\n    scanf(\"%d\", &r1);\n    printf(\"Enter the number of columns for Matrix A: \");\n    scanf(\"%d\", &c1);\n\n    // Input dimensions for Matrix B\n    printf(\"Enter the number of rows for Matrix B: \");\n    scanf(\"%d\", &r2);\n    printf(\"Enter the number of columns for Matrix B: \");\n    scanf(\"%d\", &c2);\n\n    // Check if matrix multiplication is possible\n    if (c1 != r2) {\n        printf(\"Error: Number of columns in Matrix A must be equal to number of rows in Matrix B.\\n\");\n        return 1; // Exit with error code\n    }\n\n    // Input elements for Matrix A\n    printf(\"\\nEnter elements of Matrix A (%dx%d):\\n\", r1, c1);\n    for (i = 0; i < r1; i++) {\n        for (j = 0; j < c1; j++) {\n            printf(\"Enter element A[%d][%d]: \", i, j);\n            scanf(\"%d\", &matrixA[i][j]);\n        }\n    }\n\n    // Input elements for Matrix B\n    printf(\"\\nEnter elements of Matrix B (%dx%d):\\n\", r2, c2);\n    for (i = 0; i < r2; i++) {\n        for (j = 0; j < c2; j++) {\n            printf(\"Enter element B[%d][%d]: \", i, j);\n            scanf(\"%d\", &matrixB[i][j]);\n        }\n    }\n\n    // Initialize resultMatrix with zeros\n    for (i = 0; i < r1; i++) {\n        for (j = 0; j < c2; j++) {\n            resultMatrix[i][j] = 0;\n        }\n    }\n\n    // Perform matrix multiplication\n    for (i = 0; i < r1; i++) {\n        for (j = 0; j < c2; j++) {\n            for (k = 0; k < c1; k++) { // Or k < r2 (since c1 == r2)\n                resultMatrix[i][j] += matrixA[i][k] * matrixB[k][j];\n            }\n        }\n    }\n\n    // Print the result matrix\n    printf(\"\\nResultant Matrix (m) after multiplication (%dx%d):\\n\", r1, c2);\n    for (i = 0; i < r1; i++) {\n        for (j = 0; j < c2; j++) {\n            printf(\"%d\\t\", resultMatrix[i][j]);\n        }\n        printf(\"\\n\"); // New line after each row\n    }\n\n    return 0;\n}\n```",
      "answer_source": "generated",
      "chapter": "Unit 2: Conditional Control -Statements :Simple if, if...else"
    },
    {
      "question_number": "6",
      "question_text": "Write a C program to a) Reverse a string in place b) converts a string representation of an integer to its corresponding integer value.",
      "marks": 8,
      "answer": "**C Program for String Reversal and String to Integer Conversion**\n\n```c\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h> // For atoi()\n\n// Function to reverse a string in place\nvoid reverseString(char *str) {\n    int length = strlen(str);\n    int i, j;\n    char temp;\n\n    // Use two pointers, one from start and one from end\n    for (i = 0, j = length - 1; i < j; i++, j--) {\n        temp = str[i];\n        str[i] = str[j];\n        str[j] = temp;\n    }\n    printf(\"Reversed string: %s\\n\", str);\n}\n\n// Function to convert a string representation of an integer to an integer value\nint convertStringToInt(const char *str) {\n    // Using the built-in atoi() function\n    int intValue = atoi(str);\n    printf(\"String '%s' converted to integer: %d\\n\", str, intValue);\n    return intValue;\n}\n\nint main() {\n    char str1[100]; // For string reversal\n    char str2[100]; // For string to integer conversion\n\n    // --- Part a) Reverse a string in place ---\n    printf(\"\\n--- String Reversal ---\\n\");\n    printf(\"Enter a string to reverse: \");\n    fgets(str1, sizeof(str1), stdin);\n    str1[strcspn(str1, \"\\n\")] = 0; // Remove trailing newline\n    reverseString(str1);\n\n    // --- Part b) Convert string representation of an integer to integer value ---\n    printf(\"\\n--- String to Integer Conversion ---\\n\");\n    printf(\"Enter a string representing an integer (e.g., \\\"123\\\", \\\"-45\\\"): \");\n    fgets(str2, sizeof(str2), stdin);\n    str2[strcspn(str2, \"\\n\")] = 0; // Remove trailing newline\n    convertStringToInt(str2);\n\n    return 0;\n}\n```\n\n**Explanation:**\n\n**a) Reverse a string in place (`reverseString` function):**\n1.  The function `reverseString` takes a `char *str` (a pointer to the string) as input. Since strings in C are arrays of characters, passing a `char*` allows modifications to the original string, achieving \"in-place\" reversal.\n2.  `strlen(str)` calculates the length of the string.\n3.  Two integer variables, `i` and `j`, are used as pointers/indices: `i` starts from the beginning (index 0), and `j` starts from the end (index `length - 1`).\n4.  The `for` loop continues as long as `i` is less than `j`. This ensures that characters are swapped only up to the middle of the string.\n5.  Inside the loop, `str[i]` and `str[j]` are swapped using a temporary variable `temp`.\n6.  `i` is incremented and `j` is decremented in each iteration, moving the pointers towards the center of the string.\n\n**b) Convert a string representation of an integer to its corresponding integer value (`convertStringToInt` function):**\n1.  The function `convertStringToInt` takes a `const char *str` as input. `const` is used to indicate that the function will not modify the input string.\n2.  It uses the standard C library function `atoi()` (ASCII to Integer) which is defined in `stdlib.h`.\n3.  `atoi()` takes a null-terminated string as an argument and returns its integer equivalent. If the string does not represent a valid integer, or if it is empty, `atoi()` returns 0. It handles positive, negative, and leading whitespace characters. For more robust error checking, `strtol()` is a better choice in production code, but `atoi()` directly answers the problem's intent for conversion.\n4.  The converted integer value is stored in `intValue` and then printed.\n\nThe `main` function demonstrates how to use these two functions, taking user input for both scenarios.",
      "answer_source": "generated",
      "chapter": "Unit 3: String Basics - String Declaration and Initialization"
    },
    {
      "question_number": "7",
      "question_text": "Explain the any two built-in/library string functions with syntax and example.",
      "marks": 8,
      "answer": "C provides several built-in string functions in the `<string.h>` library for common string manipulations. Here are explanations for two such functions with their syntax and examples:\n\n**1. `strlen()` (String Length)**\n*   **Purpose:** The `strlen()` function calculates the length of a given string. It counts the number of characters in the string until it encounters the null-terminator (`\\0`). The null-terminator itself is not included in the length count.\n*   **Syntax:** `size_t strlen(const char *str);`\n    *   `str`: A pointer to the null-terminated string whose length is to be calculated.\n    *   `size_t`: An unsigned integer type, typically used for sizes and counts.\n*   **Return Value:** Returns the number of characters in the string (type `size_t`).\n*   **Example:**\n    ```c\n    #include <stdio.h>\n    #include <string.h>\n\n    int main() {\n        char myString[] = \"Hello, C programming!\";\n        char emptyString[] = \"\";\n        char anotherString[10] = \"World\"; // Array of size 10, string \"World\" (length 5)\n\n        size_t len1 = strlen(myString);\n        size_t len2 = strlen(emptyString);\n        size_t len3 = strlen(anotherString);\n\n        printf(\"Length of \\\"%s\\\" is: %zu\\n\", myString, len1);    // Output: 21\n        printf(\"Length of \\\"%s\\\" is: %zu\\n\", emptyString, len2); // Output: 0\n        printf(\"Length of \\\"%s\\\" is: %zu\\n\", anotherString, len3); // Output: 5\n\n        return 0;\n    }\n    ```\n\n**2. `strcpy()` (String Copy)**\n*   **Purpose:** The `strcpy()` function copies the contents of a source string (including the null-terminator) to a destination string. It assumes that the destination buffer is large enough to hold the entire source string.\n*   **Syntax:** `char *strcpy(char *destination, const char *source);`\n    *   `destination`: A pointer to the destination character array where the content is to be copied.\n    *   `source`: A pointer to the null-terminated source string that is to be copied.\n*   **Return Value:** Returns a pointer to the destination string.\n*   **Important Note:** `strcpy()` does not perform bounds checking. If the `destination` buffer is smaller than the `source` string, it will lead to a buffer overflow, which can cause program crashes or security vulnerabilities. For safer string copying, `strncpy()` or `snprintf()` are preferred, or dynamically allocated memory should be sized correctly.\n*   **Example:**\n    ```c\n    #include <stdio.h>\n    #include <string.h>\n\n    int main() {\n        char sourceString[] = \"Copy me!\";\n        char destinationString[20]; // Ensure destination is large enough (8 chars + null = 9, so 20 is safe)\n        char anotherDestination[5]; // Too small for \"Hello!\", will cause buffer overflow if used with strcpy\n\n        printf(\"Source string: %s\\n\", sourceString);\n\n        strcpy(destinationString, sourceString);\n        printf(\"Destination string after strcpy: %s\\n\", destinationString); // Output: Copy me!\n\n        // Example of a dangerous use case (will cause buffer overflow)\n        // char shortDest[5];\n        // strcpy(shortDest, \"Hello World!\"); // WARNING: Buffer overflow!\n        // printf(\"Short destination (DANGEROUS): %s\\n\", shortDest);\n\n        return 0;\n    }\n    ```",
      "answer_source": "generated",
      "chapter": "Unit 3: String Basics - String Declaration and Initialization"
    },
    {
      "question_number": "8",
      "question_text": "Explain the concept of call by reference and call by values using suitable examples",
      "marks": 8,
      "answer": "In C programming, when a function is called, the way arguments are passed to it significantly impacts how the function interacts with the variables in the calling environment. The two primary methods are \"Call by Value\" and \"Call by Reference.\"\n\n**1. Call by Value**\n\n*   **Concept:** In call by value, a copy of the actual parameters' values is passed to the function's formal parameters. The function operates on these copies, not on the original variables themselves.\n*   **Mechanism:** When the function is called, the values of the actual arguments are copied into the formal arguments. These formal arguments are new variables created within the function's scope.\n*   **Effect:** Any modifications made to the formal parameters inside the function do *not* affect the original actual parameters in the calling function. The original variables remain unchanged.\n*   **Memory:** Actual and formal parameters reside in different memory locations.\n*   **When to Use:** When the function's purpose is to compute a result based on inputs without needing to alter the original data in the caller, or when passing small, primitive data types.\n\n**Example: Call by Value (Swap function that fails to swap)**\n```c\n#include <stdio.h>\n\nvoid swapByValue(int x, int y) { // x and y are copies of a and b\n    int temp;\n    temp = x;\n    x = y;     // Changes x (copy), not a\n    y = temp;  // Changes y (copy), not b\n    printf(\"Inside swapByValue function: x = %d, y = %d\\n\", x, y);\n}\n\nint main() {\n    int a = 10;\n    int b = 20;\n\n    printf(\"Before swapByValue: a = %d, b = %d\\n\", a, b);\n    swapByValue(a, b); // Pass copies of a and b\n    printf(\"After swapByValue: a = %d, b = %d\\n\", a, b);\n\n    return 0;\n}\n/*\nOutput:\nBefore swapByValue: a = 10, b = 20\nInside swapByValue function: x = 20, y = 10\nAfter swapByValue: a = 10, b = 20\n*/\n```\nIn this example, `swapByValue` receives copies of `a` and `b`. Swapping `x` and `y` (the copies) has no effect on `a` and `b` in `main`.\n\n--- \n\n**2. Call by Reference (or Call by Address)**\n\n*   **Concept:** In call by reference, the memory addresses of the actual parameters are passed to the function's formal parameters. The function then uses these addresses (pointers) to access and manipulate the original variables directly.\n*   **Mechanism:** When the function is called, the addresses of the actual arguments are copied into the formal arguments (which are declared as pointers). The function uses the dereference operator (`*`) to work with the values at these addresses.\n*   **Effect:** Any modifications made to the values pointed to by the formal parameters inside the function *do* affect the original actual parameters in the calling function. The original variables can be changed.\n*   **Memory:** Formal parameters (pointers) store the addresses of the actual parameters. They refer to the same memory locations.\n*   **When to Use:** When a function needs to modify the original variables passed to it, or when passing large data structures (like arrays or structs) to avoid copying them, thus improving efficiency.\n\n**Example: Call by Reference (Swap function that works)**\n```c\n#include <stdio.h>\n\nvoid swapByReference(int *x, int *y) { // x and y are pointers to a and b\n    int temp;\n    temp = *x; // Get value at address x (value of a)\n    *x = *y;   // Set value at address x (value of a) to value at address y (value of b)\n    *y = temp; // Set value at address y (value of b) to temp (original value of a)\n    printf(\"Inside swapByReference function: *x = %d, *y = %d\\n\", *x, *y);\n}\n\nint main() {\n    int a = 10;\n    int b = 20;\n\n    printf(\"Before swapByReference: a = %d, b = %d\\n\", a, b);\n    swapByReference(&a, &b); // Pass addresses of a and b\n    printf(\"After swapByReference: a = %d, b = %d\\n\", a, b);\n\n    return 0;\n}\n/*\nOutput:\nBefore swapByReference: a = 10, b = 20\nInside swapByReference function: *x = 20, *y = 10\nAfter swapByReference: a = 20, b = 10\n*/\n```\nHere, `swapByReference` receives the addresses of `a` and `b`. By dereferencing these pointers (`*x`, `*y`), the function directly accesses and modifies the original `a` and `b` in `main`.\n\n--- \n\n**Summary of Differences:**\n\n| Feature           | Call by Value                                       | Call by Reference (Call by Address)                       |\n| :---------------- | :-------------------------------------------------- | :-------------------------------------------------------- |\n| **Arguments Passed** | Copies of actual values.                            | Memory addresses of actual variables (pointers).           |\n| **Modification**  | Changes to formal parameters do NOT affect original variables. | Changes to values pointed to by formal parameters DO affect original variables. |\n| **Memory Usage**  | Separate memory locations for actual and formal parameters. | Formal parameters (pointers) point to the same memory locations as actual variables. |\n| **Efficiency**    | Less efficient for large data structures (due to copying). | More efficient for large data structures (only address is copied). |\n| **Safety**        | Safer, as original data is protected from accidental modification. | Less safe, as original data can be unintentionally modified. |\n| **Use Case**      | When functions only need to read data or return a single value. | When functions need to modify multiple original variables or work with large data. |\n| **Function Signature** | `void func(int x, int y)`                          | `void func(int *x, int *y)`                              |\n| **Function Call** | `func(a, b)`                                        | `func(&a, &b)`                                            |",
      "answer_source": "generated",
      "chapter": "Unit 3: String Basics - String Declaration and Initialization"
    },
    {
      "question_number": "9",
      "question_text": "Write a C program for\na) passing array elements by values to a function. [scenario: out of 4 array elements, pass only the second and third elements]\nb) passing entire array elements to a function. [scenario: The function should calculate the sum of all elements in the array]",
      "marks": 8,
      "answer": "**C Program for Passing Array Elements**\n\n```c\n#include <stdio.h>\n\n// a) Function to receive array elements by value\n// This function takes two integer arguments by value.\nvoid processSpecificElements(int element1, int element2) {\n    printf(\"\\n--- Inside processSpecificElements ---\\n\");\n    printf(\"Received element 1 (by value): %d\\n\", element1);\n    printf(\"Received element 2 (by value): %d\\n\", element2);\n    \n    // Modifying these local copies will not affect the original array elements\n    element1 = 99;\n    element2 = 88;\n    printf(\"Modified local copies: element1 = %d, element2 = %d\\n\", element1, element2);\n}\n\n// b) Function to receive an entire array (by reference/pointer) and calculate sum\n// Arrays are always passed by reference (decaying to a pointer to the first element)\nint calculateArraySum(int arr[], int size) {\n    printf(\"\\n--- Inside calculateArraySum ---\\n\");\n    int sum = 0;\n    printf(\"Array elements received: \");\n    for (int i = 0; i < size; i++) {\n        sum += arr[i];\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n\");\n    return sum;\n}\n\nint main() {\n    int myArray[4] = {10, 20, 30, 40};\n    int totalSum;\n\n    printf(\"Original array elements: %d %d %d %d\\n\", myArray[0], myArray[1], myArray[2], myArray[3]);\n\n    // a) Passing array elements by values to a function\n    // Pass the second (index 1) and third (index 2) elements\n    printf(\"\\nCalling processSpecificElements with myArray[1] and myArray[2]:\");\n    processSpecificElements(myArray[1], myArray[2]);\n\n    printf(\"\\nAfter calling processSpecificElements (original array unchanged): %d %d %d %d\\n\", \n           myArray[0], myArray[1], myArray[2], myArray[3]);\n\n    // b) Passing entire array elements to a function (to calculate sum)\n    printf(\"\\nCalling calculateArraySum with the entire array:\\n\");\n    totalSum = calculateArraySum(myArray, 4); // Pass the array name and its size\n    printf(\"Sum of all array elements: %d\\n\", totalSum);\n\n    // Demonstrating that the original array can be modified inside the sum function (if not declared const)\n    // For example, if we changed arr[0] in calculateArraySum, myArray[0] would change.\n\n    return 0;\n}\n```\n\n**Explanation:**\n\n**a) Passing array elements by values to a function:**\n*   The `processSpecificElements` function is designed to accept individual integer values. When `myArray[1]` and `myArray[2]` are passed to it from `main`, their *values* (20 and 30, respectively) are copied into the function's local parameters `element1` and `element2`.\n*   Any modifications made to `element1` or `element2` inside `processSpecificElements` (e.g., `element1 = 99;`) will only affect these local copies. The original `myArray[1]` and `myArray[2]` in `main` remain unchanged, demonstrating the \"call by value\" mechanism.\n\n**b) Passing entire array elements to a function (to calculate sum):**\n*   In C, arrays are **always passed by reference** (or more accurately, by pointer). When an array name (like `myArray`) is passed to a function, it decays into a pointer to its first element (`int*`).\n*   The `calculateArraySum` function receives `int arr[]` (which is equivalent to `int *arr`) and the `size` of the array.\n*   Inside the function, `arr` refers to the original array in `main`. The function iterates through `arr` from index 0 to `size-1`, summing up its elements.\n*   Because the function receives a pointer to the original array, it can directly access and even modify the original elements if it were designed to do so. In this case, it just reads them to calculate the sum. This demonstrates that operations performed on `arr` inside `calculateArraySum` directly affect the `myArray` in `main`.",
      "answer_source": "generated",
      "chapter": "Unit 3: String Basics - String Declaration and Initialization"
    }
  ]
}