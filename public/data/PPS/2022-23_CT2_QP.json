{
  "paper_title": "Programming for Problem Solving (CT2 SET1)",
  "source": "2022-23 CT2",
  "questions": [
    {
      "question_number": "1",
      "question_text": "Priya went to shopping to buy organic fruits. But the shop owner mixed the hybrid apples in that box. After Priya checked the box, she was confused between organic and hybrid apples. She started to count the hybrid apples. Write a program to help Priya count the total number of hybrid apples in the box.\nInput:\nOOOHOOOHHO\nOutput:\n7 organic apples\n#include <stdio.h>\nint main() {\nint counthybapples = 0;\nchar apples [10];\nfor(i=0; i<10; ++i)\n{\nscanf(\"%c\", &apples[i]);\n}\nif(apples[i] == 'H')\ncounthybapples++;\nprintf(\"%d hybrid apples\\n\", counthybapples);\nreturn 0;\n}",
      "marks": 5,
      "answer": "The provided code has a logical error: the `if(apples[i] == 'H') counthybapples++;` statement is placed outside the `for` loop that reads the input characters. As a result, it only checks the last character read for 'H' and potentially accesses `i` out of scope if `i` is not globally declared or retained from the loop. The `output` example also seems to contradict the input if counting 'H' (OOOHOOOHHO has 3 'H', not 7). Assuming the goal is to count hybrid apples ('H') in the input string of 10 characters, the `if` condition should be inside the `for` loop.\n\nHere is the corrected and explained program:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int counthybapples = 0;\n    char apples[10];\n    int i; // Declare i for the loop\n\n    printf(\"Enter 10 characters (O for Organic, H for Hybrid): \");\n    for(i = 0; i < 10; ++i)\n    {\n        scanf(\" %c\", &apples[i]); // Note the space before %c to consume newline characters\n        if(apples[i] == 'H')\n        {\n            counthybapples++;\n        }\n    }\n\n    printf(\"%d hybrid apples\\n\", counthybapples);\n\n    return 0;\n}\n```\n\n**Explanation:**\n1.  **Initialization**: `counthybapples` is initialized to 0 to keep track of hybrid apples. `apples[10]` is an array to store 10 characters.\n2.  **Input Loop**: A `for` loop iterates 10 times to read each character. The `scanf(\" %c\", &apples[i]);` uses a space before `%c` to consume any leftover whitespace characters (like the newline from pressing Enter after each character) in the input buffer, ensuring it reads the actual character.\n3.  **Counting Hybrid Apples**: Inside the input loop, `if(apples[i] == 'H')` checks if the current character is 'H'. If it is, `counthybapples` is incremented.\n4.  **Output**: After the loop finishes, the total count of hybrid apples is printed.\n\nFor the input \"OOOHOOOHHO\", the output would be \"3 hybrid apples\".",
      "answer_source": "generated",
      "chapter": "Unit 2: Conditional Control -Statements :Simple if, if...else"
    },
    {
      "question_number": "2",
      "question_text": "The Election Commission of India distributed the voter ID to all eligible citizens. But Amira didn't received a Voter ID on time. So, she gets confused about her eligibility for voting? Write a program to find out the eligibility of based person on age and clarify her doubt?\n#include <stdio.h>\nint main()\n{\nint age; scanf(\"%d\",&age);\n{\n}\nif(age<18)\nprintf(\"Not Eligible\");\nelse\n{\n}\nprintf(\"Eligible\");\nreturn 0;\n}",
      "marks": 5,
      "answer": "The provided code correctly determines voting eligibility based on age. The empty curly braces `{}` are syntactically valid but unnecessary. The `printf(\"Eligible\");` statement for the `else` case is misplaced outside its block. It should be inside the `else` block to be part of the conditional execution.\n\nHere is the corrected and explained program:\n\n```c\n#include <stdio.h>\n\nint main()\n{\n    int age;\n\n    printf(\"Enter Amira's age: \");\n    scanf(\"%d\", &age);\n\n    if(age < 18)\n    {\n        printf(\"Not Eligible\\n\");\n    }\n    else\n    {\n        printf(\"Eligible\\n\");\n    }\n    \n    return 0;\n}\n```\n\n**Explanation:**\n1.  **Input**: The program prompts the user to enter Amira's age and stores it in the `age` integer variable.\n2.  **Conditional Check**: An `if-else` statement is used:\n    *   If `age` is less than 18, it prints \"Not Eligible\".\n    *   Otherwise (if `age` is 18 or greater), it prints \"Eligible\".\n3.  **Return**: The program then exits gracefully by returning 0.",
      "answer_source": "generated",
      "chapter": "Unit 2: Conditional Control -Statements :Simple if, if...else"
    },
    {
      "question_number": "3",
      "question_text": "Yusuf is an active young man who is very interested in getting money in a simple way. So he is always looking for a way to get some money. One day, he came to know about a money-making show called 'Crorepati' on a popular channel. So he participated the Crorepati game. It has a dial full of numbers in random order. If it is arranged in specified order, he would win a million-dollar prize. Can you help him to win the game by writing C program?#include<stdio.h>\nint main()\n{\nint a[100],n;\nprintf(\"enter no of values\");\nscanf(\"%d\", &n);\nfor(int i=0; i<n; i++)\n{\nprintf(\"enter n values\");\nscanf(\"%d\",&a[i]);\n}\nint i,j,temp;\nfor(i=0; i<n-1; i++)\n{\nfor(j=0; j<n-i-1; j++)\n{\nif(a[j]>a[j+1])\n{\ntemp=a[j];\na[j]=a[j+1];\na[j+1]=temp;\n}\n}\n}\nfor(i=0; i<n; i++)\n{\nprintf(\"%d \",a[i]);\n}\nreturn 0;\n}",
      "marks": 5,
      "answer": "The provided code correctly implements the Bubble Sort algorithm to sort an array of integers in ascending order. The variable `i` for the second `for` loop is declared again, which is redundant as `i` is already declared at the top of `main`. It also has an extra `printf(\"enter n values\");` inside the input loop which is confusing.\n\nHere is the cleaned-up and explained program:\n\n```c\n#include <stdio.h>\n\nint main()\n{\n    int a[100]; // Declare an array to hold up to 100 integers\n    int n;      // Variable to store the number of values\n\n    printf(\"Enter the number of values: \");\n    scanf(\"%d\", &n);\n\n    // Input validation: ensure n is within array bounds\n    if (n <= 0 || n > 100) {\n        printf(\"Invalid number of values. Please enter a number between 1 and 100.\\n\");\n        return 1; // Indicate an error\n    }\n\n    printf(\"Enter %d integer values:\\n\", n);\n    for(int i = 0; i < n; i++)\n    {\n        scanf(\"%d\", &a[i]);\n    }\n\n    // Bubble Sort algorithm\n    int i, j, temp; // Declare loop counters and a temporary variable\n    for(i = 0; i < n - 1; i++) // Outer loop for passes\n    {\n        for(j = 0; j < n - i - 1; j++) // Inner loop for comparisons and swaps\n        {\n            // Compare adjacent elements\n            if(a[j] > a[j+1])\n            {\n                // Swap if elements are in the wrong order\n                temp = a[j];\n                a[j] = a[j+1];\n                a[j+1] = temp;\n            }\n        }\n    }\n\n    // Print the sorted array\n    printf(\"Sorted array (ascending order): \");\n    for(i = 0; i < n; i++)\n    {\n        printf(\"%d \", a[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n```\n\n**Explanation:**\n1.  **Input**: The program first prompts the user to enter the number of elements `n`, then reads `n` integer values into the array `a`.\n2.  **Bubble Sort Logic**: It uses nested `for` loops to implement Bubble Sort:\n    *   The outer loop runs `n-1` times, as in each pass, at least one element (the largest unsorted) bubbles to its correct position.\n    *   The inner loop compares adjacent elements (`a[j]` and `a[j+1]`). If `a[j]` is greater than `a[j+1]`, they are swapped using a temporary variable `temp`.\n    *   The `n - i - 1` in the inner loop's condition optimizes it by not re-checking the elements that are already in their sorted final positions at the end of the array.\n3.  **Output**: After sorting, another `for` loop prints all the elements of the array in their new, sorted order.",
      "answer_source": "generated",
      "chapter": "Unit 2: Looping Control Statements: nested for, nested while"
    },
    {
      "question_number": "4",
      "question_text": "Tina is a B.Tech student. During her final year campus interview, she had an opportunity to get a job in a software company at Bangalore. The company provides five months training period with Rs.40,000/month package.\nThen it will be incremented to Rs.65, 000 per month. At the end of the training, a test was conducted for all fresher, Tina got a question paper and one of the question is from the concept of programming. The program was that she has to calculate the sum of an array of elements, which are even. Help her to complete the test successfully.\n#include <stdio.h>\n{\nint main()\nint N,start;\n{\nscanf(\"%d\",&N);\nint arr[N];\nfor (int i=0;i<N;i++)\n{\nprintf(\"enter value\");\nscanf (\"%d\",&arr[i]);\n}\nint i;\nfor(i=0;i<N;i++)\nstart+=arr[i];\n}\nprintf(\"%d\",start);\n}",
      "marks": 5,
      "answer": "The provided code has several syntax and logical errors:\n1.  **Syntax Errors**: The `main` function structure is incorrect (missing opening brace after `int main()` and an extra closing brace `}` after the input loop).\n2.  **Variable Initialization**: `start` variable is not initialized, which will lead to undefined behavior when `start+=arr[i]` is executed.\n3.  **Logical Error**: The problem asks to sum *even* elements, but the provided code sums *all* elements of the array.\n\nHere is the corrected and explained program:\n\n```c\n#include <stdio.h>\n\nint main()\n{\n    int N; // To store the size of the array\n    int sumOfEvens = 0; // Initialize sum to 0 (important!)\n\n    printf(\"Enter the number of elements for the array: \");\n    scanf(\"%d\", &N);\n\n    // Input validation for array size\n    if (N <= 0) {\n        printf(\"Array size must be positive.\\n\");\n        return 1; // Indicate an error\n    }\n\n    int arr[N]; // Declare a variable-length array (VLA)\n\n    printf(\"Enter %d integer values:\\n\", N);\n    for (int i = 0; i < N; i++) // Loop to read array elements\n    {\n        printf(\"Enter value for arr[%d]: \", i);\n        scanf(\"%d\", &arr[i]);\n    }\n\n    // Loop to calculate the sum of even elements\n    for(int i = 0; i < N; i++)\n    {\n        if (arr[i] % 2 == 0) // Check if the current element is even\n        {\n            sumOfEvens += arr[i]; // Add to sum if it's even\n        }\n    }\n\n    printf(\"The sum of even elements in the array is: %d\\n\", sumOfEvens);\n\n    return 0;\n}\n```\n\n**Explanation:**\n1.  **Input Size**: The program first prompts the user to enter the number of elements `N` for the array.\n2.  **Array Declaration and Input**: It then declares a Variable-Length Array (VLA) `arr[N]` and uses a `for` loop to read `N` integer values from the user into this array.\n3.  **Sum of Even Elements**: A second `for` loop iterates through the array. Inside this loop, an `if` condition `(arr[i] % 2 == 0)` checks if the current element `arr[i]` is an even number (i.e., its remainder when divided by 2 is 0).\n4.  **Accumulation**: If the element is even, it is added to the `sumOfEvens` variable. `sumOfEvens` is initialized to 0 to ensure a correct starting sum.\n5.  **Output**: Finally, the total `sumOfEvens` is printed to the console.",
      "answer_source": "generated",
      "chapter": "Unit 2: Introduction to Arrays -One Dimensional (1D) Array Declaration and initialization"
    },
    {
      "question_number": "5",
      "question_text": "Rathik organized technical round interview in Microsoft for computer science candidates. The problem is to perform addition, subtraction, multiplication, and division of two given numbers. Rathik has given the deadline of only 5 minutes to complete the problem. Can you help the candidates by writing C program to complete the problem within the specified time limit? Note: Rathik instructed the candidates to print the result of the division with 3 values after decimal point.\n#include<stdio.h>\n//#include<conio.h>\nint main()\n{\nfloat a,b;\nint op;\nprintf(\" 1.Addition\\n 2.Subtraction\\n 3.Multiplication\\n 4.Division\\n\");\nprintf(\"Enter the values of a & b: \");\nscanf(\"%d %d\",&a,&b);\nprintf(\"Enter your Choice : \");\nscanf(\"%d\",&op);\nswitch(op)\n{\ncase 1:\nprintf(\"Sum of %f and %f is : %f\",a,b,a+b);\nbreak;\ncase 2:\nprintf(\"Difference of %f and %f is: %f\",a,b,a-b);\nbreak;\ncase 3:\nprintf(\"Multiplication of %f and %f is : %f\",a,b,a*b);\nbreak;\ncase 4:\nprintf(\"Division of Two Numbers is %.3f : \",a/b);\nbreak;\ndefault:\nprintf(\" Enter Your Correct Choice.\");\nbreak;\n}\nreturn 0;\n}",
      "marks": 5,
      "answer": "The provided code for a simple calculator using `switch-case` is mostly correct but has a critical error in reading floating-point numbers. `scanf(\"%d %d\",&a,&b);` attempts to read two integers into `float` variables (`a` and `b`), which leads to incorrect values. It should use `%f` format specifier for floats.\n\nHere is the corrected and explained program:\n\n```c\n#include<stdio.h>\n\nint main()\n{\n    float a, b; // Variables to store the two numbers\n    int op;     // Variable to store the user's choice of operation\n\n    printf(\"Simple Calculator\\n\");\n    printf(\" 1. Addition\\n\");\n    printf(\" 2. Subtraction\\n\");\n    printf(\" 3. Multiplication\\n\");\n    printf(\" 4. Division\\n\");\n\n    printf(\"Enter the values of a & b: \");\n    scanf(\"%f %f\", &a, &b); // Corrected: Use %f for float input\n\n    printf(\"Enter your Choice (1-4): \");\n    scanf(\"%d\", &op);\n\n    switch(op)\n    {\n        case 1:\n            printf(\"Sum of %.2f and %.2f is : %.2f\\n\", a, b, a + b);\n            break;\n        case 2:\n            printf(\"Difference of %.2f and %.2f is: %.2f\\n\", a, b, a - b);\n            break;\n        case 3:\n            printf(\"Multiplication of %.2f and %.2f is : %.2f\\n\", a, b, a * b);\n            break;\n        case 4:\n            if (b != 0) {\n                printf(\"Division of %.2f by %.2f is: %.3f\\n\", a, b, a / b); // Output with 3 decimal places as per note\n            } else {\n                printf(\"Error: Division by zero is not allowed.\\n\");\n            }\n            break;\n        default:\n            printf(\"Invalid Choice. Please enter a number between 1 and 4.\\n\");\n            break;\n    }\n\n    return 0;\n}\n```\n\n**Explanation:**\n1.  **Input**: The program first displays a menu of arithmetic operations. It then prompts the user to enter two floating-point numbers (`a` and `b`) and their choice of operation (`op`).\n2.  **`switch` Statement**: A `switch` statement is used to execute different code blocks based on the user's `op` choice.\n    *   **Cases 1-3 (Addition, Subtraction, Multiplication)**: The respective arithmetic operation is performed on `a` and `b`, and the result is printed, formatted to two decimal places.\n    *   **Case 4 (Division)**: It first checks if `b` is zero to prevent division by zero errors. If `b` is not zero, the division `a/b` is performed, and the result is printed, formatted to three decimal places as specified in the problem statement. If `b` is zero, an error message is displayed.\n    *   **`default` Case**: If the user enters an `op` value that is not between 1 and 4, the `default` case is executed, informing the user of an invalid choice.\n3.  **`break` Statements**: `break` statements are used after each `case` to exit the `switch` block once a match is found and its code executed.",
      "answer_source": "generated",
      "chapter": "Unit 2: Conditional Control -Statements : Switch case"
    },
    {
      "question_number": "6",
      "question_text": "Simon is wasting electricity without caring about it. He leaves all switches ON even when he is not in the room. After a month of using Electricity, his security Guard informed him about increased units of electricity. Due to the electricity bill, Simon gets tensed about his electricity bill. Can you help Simon to calculate his electric bill using C program?\nConstraints:\nUnits                     Charges per unit(Rs)\nUpto 50                   0.50\nAbove 50 and less than 150  0.75\nAbove 150 and less than 250 1.2\nAbove 250                 1.5\nIf bill exceeds Rs. 300 then a surcharge of 10% will be charged.\n#include<stdio.h>\n{\nfloat bill(int unit);\nint main()\nint n;\nscanf(\"%d\", &n);\nfloat total = bill(n);\nprintf(\"%.2f\", total);\nreturn 0;\n}\nfloat bill(int unit)\n{\nif(unit < 50) return unit*0.50;\nelse if(unit <= 50)\nreturn (((unit-50)*0.75) + 25);\nelse if(unit <= 250)\nreturn (((unit-150)*1.20)+100);\nelse return (((unit-250)*1.50) + 220);\nreturn 0;\n}",
      "marks": 5,
      "answer": "The provided code attempts to calculate an electricity bill based on tiered rates and a surcharge. However, it has several issues:\n1.  **Syntax Errors**: The `main` function body is not correctly enclosed in curly braces `{}`. `return 0;` in the `bill` function is unreachable.\n2.  **Logical Errors in Tiered Calculation**: The `else if(unit <= 50)` condition is redundant and incorrect after `if(unit < 50)`. More importantly, the tiered calculation logic is flawed. For example, for units `> 50` and `<= 150`, it should calculate `(50 * 0.50) + ((unit - 50) * 0.75)`, not just `((unit-50)*0.75) + 25` (where 25 is `50*0.50`). The values 100 and 220 seem to be pre-calculated sums of previous slabs, which is correct for a cumulative approach, but the `else if` conditions need to be precise for the current slab.\n3.  **Surcharge**: The 10% surcharge for bills exceeding Rs. 300 is not implemented.\n\nHere is the corrected and explained program:\n\n```c\n#include<stdio.h>\n\n// Function prototype\nfloat calculateBill(int units);\n\nint main()\n{\n    int unitsConsumed; // Variable to store units consumed\n\n    printf(\"Enter the number of electricity units consumed: \");\n    scanf(\"%d\", &unitsConsumed);\n\n    float totalBill = calculateBill(unitsConsumed);\n\n    // Apply surcharge if total bill exceeds Rs. 300\n    if (totalBill > 300)\n    {\n        totalBill += totalBill * 0.10; // Add 10% surcharge\n        printf(\"Surcharge of 10%% applied.\\n\");\n    }\n\n    printf(\"Total electricity bill: Rs. %.2f\\n\", totalBill);\n\n    return 0;\n}\n\n// Function to calculate the electricity bill based on units\nfloat calculateBill(int units)\n{\n    float billAmount = 0.0;\n\n    if (units <= 50)\n    {\n        billAmount = units * 0.50;\n    }\n    else if (units <= 150) // Units from 51 to 150\n    {\n        billAmount = (50 * 0.50) + ((units - 50) * 0.75);\n    }\n    else if (units <= 250) // Units from 151 to 250\n    {\n        billAmount = (50 * 0.50) + (100 * 0.75) + ((units - 150) * 1.20);\n    }\n    else // Units above 250\n    {\n        billAmount = (50 * 0.50) + (100 * 0.75) + (100 * 1.20) + ((units - 250) * 1.50);\n    }\n\n    return billAmount;\n}\n```\n\n**Explanation:**\n1.  **`calculateBill` Function**: This function takes the `units` consumed as input and calculates the bill based on the specified tiered rates.\n    *   It uses an `if-else if` ladder to check which slab the `units` fall into.\n    *   For each slab, it calculates the cumulative cost: the cost of previous slabs (fixed) plus the cost of the current slab's units at its specific rate.\n    *   For example, for `units <= 150`, it sums the cost of the first 50 units (`50 * 0.50`) and the cost of units beyond 50 up to 150 (`(units - 50) * 0.75`).\n2.  **`main` Function**: \n    *   It prompts the user to enter the `unitsConsumed`.\n    *   It calls `calculateBill` to get the base bill amount.\n    *   **Surcharge Logic**: It then checks if `totalBill` exceeds `300`. If it does, a 10% surcharge (`totalBill * 0.10`) is added to the `totalBill`.\n    *   Finally, it prints the `totalBill`, formatted to two decimal places.",
      "answer_source": "generated",
      "chapter": "Unit 3: Function prototype declaration, function definition"
    },
    {
      "question_number": "7",
      "question_text": "Sajid was booking a train ticket from Chennai to Delhi. Two of the relatives was interested in joining that journey. So, Sajid booked tickets for those persons also. At the time of payment he is having Rs.5000/- only.\nNow you help him by writing C program to calculate total amount needed for their travel and how much balance he has to pay (or) how much balance he will receive. NOTE: 1 Ticket Fair Rs.2000/-\n#include <stdio.h>\n{\nint main()\n}\nint paid = 5000;\nint rel_tickets = 2;\nprintf(\"Balance to be received is %d\", 5000-2000*2);\nreturn 0;\n}",
      "marks": 5,
      "answer": "The provided code has syntax errors due to incorrect placement of `main` function's body and variable declarations. The `main` function needs to encapsulate all its executable code and local variable declarations within its curly braces.\n\nHere is the corrected and explained program:\n\n```c\n#include <stdio.h>\n\nint main()\n{\n    const int TICKET_PRICE = 2000; // Price of one ticket\n    const int SAJID_MONEY = 5000;  // Amount Sajid has\n    int num_relatives = 2;         // Number of relatives joining\n\n    // Calculate total tickets needed (Sajid + relatives)\n    int total_tickets = 1 + num_relatives;\n\n    // Calculate the total cost of tickets\n    int total_cost = total_tickets * TICKET_PRICE;\n\n    // Calculate balance\n    int balance = SAJID_MONEY - total_cost;\n\n    printf(\"Total tickets booked: %d\\n\", total_tickets);\n    printf(\"Total cost of tickets: Rs. %d\\n\", total_cost);\n    printf(\"Sajid has: Rs. %d\\n\", SAJID_MONEY);\n\n    if (balance >= 0)\n    {\n        printf(\"Balance to be received: Rs. %d\\n\", balance);\n    }\n    else\n    {\n        printf(\"Amount to be paid: Rs. %d\\n\", -balance); // Negative balance means amount to pay\n    }\n\n    return 0;\n}\n```\n\n**Explanation:**\n1.  **Constants and Variables**: `TICKET_PRICE` and `SAJID_MONEY` are defined as constants for clarity. `num_relatives` is set to 2.\n2.  **Total Tickets and Cost**: The program calculates the `total_tickets` (Sajid + 2 relatives = 3 tickets) and then the `total_cost` by multiplying the total tickets by `TICKET_PRICE`.\n3.  **Calculate Balance**: `balance` is calculated by subtracting `total_cost` from `SAJID_MONEY`.\n4.  **Output**: \n    *   If `balance` is greater than or equal to 0, it means Sajid receives money back, and that amount is printed.\n    *   If `balance` is negative, it means Sajid needs to pay, and the absolute value of `balance` is printed as the amount to be paid.\n\nGiven the values: Total tickets = 1 (Sajid) + 2 (relatives) = 3 tickets. Total cost = 3 * 2000 = 6000 Rs. Sajid has 5000 Rs. So, Sajid needs to pay 1000 Rs. The original code's `printf(\"Balance to be received is %d\", 5000-2000*2);` calculated 5000 - 4000 = 1000, which is `5000 - (2 * TICKET_PRICE)`. This implies only Sajid and 2 *relatives'* tickets are considered, which makes it 3 tickets total. My interpretation aligns with the example calculation for 3 tickets and 5000 available.",
      "answer_source": "generated",
      "chapter": "Unit 1: Input and output statements. Variables and identifiers, Constants, Keywords"
    },
    {
      "question_number": "8",
      "question_text": "Tharun wants to print a document with \"N\" pages double- sided, where two pages of data can be printed on one sheet of paper. Can you tell him for printing N pages at least how many sheets of paper does he need?\n#include <stdio.h>\nint main()\n{\nint a;\nscanf(\"%d\",&a);\nif(a%2==0)\n{\nprintf(\"%d\",a/2);}\nelse\n{\n}\nprintf(\"%d\",(a/2)+1);\nreturn 0;\n}",
      "marks": 5,
      "answer": "The provided code correctly calculates the minimum number of sheets required for double-sided printing based on the number of pages. It handles both even and odd page counts correctly using integer division and an `if-else` statement. The empty curly braces `{}` in the `else` block are syntactically valid but unnecessary. The `printf` for the `else` case is outside its block.\n\nHere is the corrected and explained program:\n\n```c\n#include <stdio.h>\n\nint main()\n{\n    int numberOfPages; // Variable to store the total number of pages\n\n    printf(\"Enter the total number of pages (N): \");\n    scanf(\"%d\", &numberOfPages);\n\n    // Input validation: pages should be positive\n    if (numberOfPages <= 0) {\n        printf(\"Number of pages must be positive.\\n\");\n        return 1; // Indicate an error\n    }\n\n    int sheetsNeeded;\n\n    if (numberOfPages % 2 == 0) // If the number of pages is even\n    {\n        sheetsNeeded = numberOfPages / 2; // Each sheet takes 2 pages, so divide by 2\n    }\n    else // If the number of pages is odd\n    {\n        sheetsNeeded = (numberOfPages / 2) + 1; // Integer division truncates, add 1 for the last single page\n    }\n\n    printf(\"To print %d pages, Tharun needs at least %d sheets of paper.\\n\", numberOfPages, sheetsNeeded);\n\n    return 0;\n}\n```\n\n**Explanation:**\n1.  **Input**: The program prompts the user to enter the total number of pages (`numberOfPages`).\n2.  **Conditional Logic**: An `if-else` statement checks if the `numberOfPages` is even or odd:\n    *   **Even Pages**: If `numberOfPages % 2 == 0` (even), then each sheet holds 2 pages, so the number of sheets required is simply `numberOfPages / 2` (integer division).\n    *   **Odd Pages**: If `numberOfPages` is odd, then `numberOfPages / 2` (integer division) will give the number of full sheets needed, and an additional sheet is required for the single remaining page. So, `(numberOfPages / 2) + 1` is calculated.\n3.  **Output**: The calculated `sheetsNeeded` is then printed.",
      "answer_source": "generated",
      "chapter": "Unit 2: Conditional Control -Statements :Simple if, if...else"
    },
    {
      "question_number": "9",
      "question_text": "Vishal is fighting with a monster. The health of the monster is H. In one attack, Vishal can decrease themonster's health by 'A'. There is no other way to decrease the monster's health. Vishal wins when the monster's health becomes '0' or below.\nCan you find the number of attacks needed for Vishal for winning?\n#include <stdio.h> int main()\n{\nint a,b;\nscanf (\"%d %d\",&a, &b);\nif (a%b==0)\n{\nprintf(\"%d\",a/b);\n}\nelse if(a/b!=0)\n{\n}\nprintf(\"%d\",(a/b)+1);\nreturn 0;\n}",
      "marks": 5,
      "answer": "The provided code calculates the number of attacks needed to defeat a monster. It uses `a` for monster's health (H) and `b` for attack power (A). The logic correctly determines the number of attacks, taking into account whether the health is perfectly divisible by the attack power. The condition `else if(a/b!=0)` is redundant; a simple `else` would suffice. Also, the `printf` for the `else` case is outside its block.\n\nHere is the corrected and explained program:\n\n```c\n#include <stdio.h>\n\nint main()\n{\n    int monsterHealth; // H - Monster's health\n    int attackPower;   // A - Vishal's attack power per hit\n\n    printf(\"Enter monster's health (H): \");\n    scanf(\"%d\", &monsterHealth);\n\n    printf(\"Enter Vishal's attack power (A): \");\n    scanf(\"%d\", &attackPower);\n\n    // Input validation: health and attack power should be positive\n    if (monsterHealth <= 0 || attackPower <= 0) {\n        printf(\"Health and attack power must be positive.\\n\");\n        return 1; // Indicate an error\n    }\n\n    int numberOfAttacks;\n\n    if (monsterHealth % attackPower == 0) // If health is perfectly divisible by attack power\n    {\n        numberOfAttacks = monsterHealth / attackPower;\n    }\n    else // If health is not perfectly divisible, one extra attack is needed\n    {\n        numberOfAttacks = (monsterHealth / attackPower) + 1; // Integer division implicitly floors\n    }\n\n    printf(\"Vishal needs %d attacks to defeat the monster.\\n\", numberOfAttacks);\n\n    return 0;\n}\n```\n\n**Explanation:**\n1.  **Input**: The program prompts the user to enter the monster's `monsterHealth` (H) and Vishal's `attackPower` (A).\n2.  **Conditional Logic**: An `if-else` statement is used to determine the number of attacks:\n    *   **Perfect Division**: If `monsterHealth` is perfectly divisible by `attackPower` (i.e., `monsterHealth % attackPower == 0`), then the number of attacks is simply `monsterHealth / attackPower` (integer division).\n    *   **Remainder**: If there is a remainder (the health is not perfectly divisible), it means even after `monsterHealth / attackPower` full attacks, some health remains. Therefore, one additional attack is needed to bring the health to 0 or below. The expression `(monsterHealth / attackPower) + 1` correctly handles this because integer division `monsterHealth / attackPower` naturally truncates any fractional part.\n3.  **Output**: The calculated `numberOfAttacks` is then printed.",
      "answer_source": "generated",
      "chapter": "Unit 2: Conditional Control -Statements :Simple if, if...else"
    },
    {
      "question_number": "10",
      "question_text": "Binita is playing chess. The game will be played on a rectangular grid consisting of N rows and M columns. Initially all the cells of the grid are uncoloured.\nBinita's initial score is zero. At each turn, she chooses some cell that is yet not colored, and colors that cell. The score obtained in this step will be number of neighboring-colored cells of the cell that Binita colored in this step.\nTwo cells are neighbours of each other if they share a side between them. The game will end when all the cells are colored. Finally, total score obtained at the end of the game will be sum of scores obtained in each turn.\nBinita wants to know what maximum score she can get? Can you please help her in finding this out?\n#include <stdio.h> int main()\n{\nint n,m; int a;\nscanf(\"%d %d\",&n,&m);\na = 2*m*n-m-n;\nprintf(\"%d\",a);\nreturn 0;\n}",
      "marks": 5,
      "answer": "The provided code correctly calculates the maximum possible score Binita can get in the grid coloring game. The problem describes a scenario where the score is accumulated by counting already colored neighbors. The maximum score is achieved by maximizing adjacencies as cells are colored. The formula `2*m*n - m - n` calculates this maximum score.\n\nHere is the explained program:\n\n```c\n#include <stdio.h>\n\nint main()\n{\n    int nRows, mCols; // Variables for number of rows (N) and columns (M)\n\n    printf(\"Enter the number of rows (N): \");\n    scanf(\"%d\", &nRows);\n    printf(\"Enter the number of columns (M): \");\n    scanf(\"%d\", &mCols);\n\n    // Input validation\n    if (nRows <= 0 || mCols <= 0) {\n        printf(\"Number of rows and columns must be positive.\\n\");\n        return 1; // Indicate an error\n    }\n\n    // Calculate the maximum score using the derived formula\n    // The formula 2*N*M - N - M represents the maximum possible sum of adjacencies\n    // when coloring a grid sequentially.\n    int maxScore = (2 * nRows * mCols) - nRows - mCols;\n\n    printf(\"The maximum score Binita can get is: %d\\n\", maxScore);\n\n    return 0;\n}\n```\n\n**Explanation:**\n1.  **Input**: The program takes two integer inputs, `nRows` (N) and `mCols` (M), representing the dimensions of the grid.\n2.  **Formula Application**: The core of the solution is the mathematical formula `2*nRows*mCols - nRows - mCols`. This formula represents the sum of all possible unique adjacencies (shared sides) between cells in an `N x M` grid when cells are colored in an optimal way (e.g., sequentially row by row). Each internal cell contributes 4 to the score (itself and 3 neighbors already colored + 1 current cell being colored). Edge cells contribute 3 or 2. This formula aggregates the total count.\n3.  **Output**: The calculated `maxScore` is printed.\n\nThis is a known result in combinatorics for grid problems: the sum of degrees of vertices in a grid graph where new edges are formed with already visited nodes. It's often equivalent to `(Total number of cells * 2) - (Number of rows) - (Number of columns)` which is `2NM - N - M`.",
      "answer_source": "generated",
      "chapter": "Unit 1: Input and output statements. Variables and identifiers, Constants, Keywords"
    },
    {
      "question_number": "11",
      "question_text": "The sweet seller is stocking the sweet laddus from the box to single container. Each container can hold single laddu only. Now write a C program to help the sweet seller for stocking laddus. The size of the box is M*N.\nLaddus are equal in size.\n(If box contains more laddus than containers, then containers get filled and some laddus remain in box. If more containers than laddus in box, some containers remain unfilled)\n#include <stdio.h>\n#include <string.h>\n{\nint main()\nint length, breadth, num_containers;\nprintf(\"No. of laddus in each row:\");\nscanf(\"%d\", &length);\nprintf(\"No. of laddus in each column:\");\nscanf(\"%d\", &breadth);\nprintf(\"No. of containers\");\nscanf(\"%d\", &num_containers);\nint rem = length*breadth - num_containers;\nif(rem >= 0)\nprintf(\"No. of laddus remaining in box after filling %d containers is %d\", num_containers, rem);\nelse{\nprintf(\"Laddus over after filling %d containers\\n\", length*breadth);\nprintf(\"No of containers remaining to fill is %d\", -rem);\n}\nreturn 0; }",
      "marks": 25,
      "answer": "The provided code has syntax errors due to the `main` function's structure (missing opening curly brace for `main`'s body) and includes `string.h` which is not used. The logic for calculating the remaining laddus or unfilled containers is correct. `length*breadth` represents the total number of laddus available, and `num_containers` represents the capacity.\n\nHere is the corrected and explained program:\n\n```c\n#include <stdio.h>\n// #include <string.h> is not needed for this program\n\nint main()\n{\n    int length, breadth;        // Dimensions of the box holding laddus\n    int num_containers;         // Total number of available containers\n\n    printf(\"Enter the number of laddus in each row (length): \");\n    scanf(\"%d\", &length);\n\n    printf(\"Enter the number of laddus in each column (breadth): \");\n    scanf(\"%d\", &breadth);\n\n    printf(\"Enter the total number of containers available: \");\n    scanf(\"%d\", &num_containers);\n\n    // Input validation\n    if (length <= 0 || breadth <= 0 || num_containers <= 0) {\n        printf(\"All inputs must be positive integers.\\n\");\n        return 1;\n    }\n\n    int total_laddus = length * breadth; // Calculate total laddus in the box\n\n    // Calculate the difference: (laddus - containers)\n    // A positive difference means laddus remaining (after filling all containers)\n    // A negative difference means containers remaining unfilled (after using all laddus)\n    int difference = total_laddus - num_containers;\n\n    if (difference >= 0) // Case 1: Laddus are equal to or more than containers\n    {\n        printf(\"All %d containers are filled. There are %d laddus remaining in the box.\\n\", num_containers, difference);\n    }\n    else // Case 2: Containers are more than laddus\n    {\n        printf(\"All %d laddus have been placed. There are %d containers remaining to be filled.\\n\", total_laddus, -difference); // -difference to show positive number of unfilled containers\n    }\n\n    return 0;\n}\n```\n\n**Explanation:**\n1.  **Input**: The program takes three integer inputs: `length` and `breadth` to determine the total number of laddus (as `length * breadth`), and `num_containers` for the available containers.\n2.  **Calculate Total Laddus**: `total_laddus` is computed by multiplying `length` and `breadth`.\n3.  **Calculate Difference**: The `difference` is found by subtracting `num_containers` from `total_laddus`.\n4.  **Conditional Output**: An `if-else` statement handles two scenarios:\n    *   **`difference >= 0` (Laddus >= Containers)**: This means all containers can be filled. The output states that all `num_containers` are filled, and `difference` laddus are `remaining` in the box.\n    *   **`difference < 0` (Laddus < Containers)**: This means not all containers can be filled. The output states that all `total_laddus` have been placed, and `-difference` (the absolute value of the negative difference) containers `remaining to be filled`.",
      "answer_source": "generated",
      "chapter": "Unit 2: Conditional Control -Statements :Simple if, if...else"
    },
    {
      "question_number": "12",
      "question_text": "Arun and Ria are playing game by finding the number of ZEROs and ONEs in the given input. This input contains 'ZEROS and ONEs' only. If the given input contains only ZEROS (or) Only ONEs then print the statement 'YES' otherwise print the statement 'NO'.\n#include <stdio.h>\n#include <string.h>\nint main()\n{\nint T,n1,n0, len, i;\nchar str[100002];\nscanf(\"%d\",&T);\nwhile(T--)\n{\nscanf(\"%s\", str);\nn1=n0=0;\nlen=strlen(str);\n{\nfor(i=0;i<len;i++)\nif(str[i]=='0')\n++n0;\nelse\n++n1;\n}\n{\nif(n1==len||n0==len)\nprintf(\"YES\\n\");\n}\nelse{ printf(\"NO\\n\");\n}\n}\nreturn 0;\n}",
      "marks": 25,
      "answer": "The provided code aims to check if a given string contains only '0's or only '1's. It uses a `while(T--)` loop for multiple test cases. There are several syntax issues with misplaced curly braces `{}` and an `else` statement not properly associated with an `if`. The logic for counting '0's and '1's and then determining if all characters are the same is correct.\n\nHere is the corrected and explained program:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main()\n{\n    int T; // Number of test cases\n    printf(\"Enter the number of test cases (T): \");\n    scanf(\"%d\", &T);\n\n    while(T--) // Loop through each test case\n    {\n        char str[100002]; // Array to store the input string\n        int n1 = 0;       // Counter for '1's\n        int n0 = 0;       // Counter for '0's\n        int len;          // Length of the string\n        int i;            // Loop counter\n\n        printf(\"Enter the string (containing only '0's and '1's): \");\n        scanf(\"%s\", str); // Read the string\n\n        len = strlen(str); // Get the length of the string\n\n        // Loop to count '0's and '1's\n        for(i = 0; i < len; i++)\n        {\n            if(str[i] == '0')\n            {\n                n0++; // Increment '0' count\n            }\n            else if (str[i] == '1') // Ensure it's '1' to be safe, though problem implies only 0s and 1s\n            {\n                n1++; // Increment '1' count\n            }\n            // Optional: add an else to handle invalid characters if necessary\n        }\n\n        // Check if the string contains only '0's or only '1's\n        if(n1 == len || n0 == len) // If all characters are '1's OR all characters are '0's\n        {\n            printf(\"YES\\n\");\n        }\n        else\n        {\n            printf(\"NO\\n\");\n        }\n    }\n\n    return 0;\n}\n```\n\n**Explanation:**\n1.  **Multiple Test Cases**: The program reads an integer `T` for the number of test cases and processes each string within a `while(T--)` loop.\n2.  **Input and Length**: For each test case, it reads a string `str` and determines its `len`gth using `strlen()` from `string.h`.\n3.  **Counting Characters**: A `for` loop iterates through the characters of the string:\n    *   If a character is '0', `n0` is incremented.\n    *   If a character is '1', `n1` is incremented.\n4.  **Condition Check**: After counting, an `if-else` statement checks the condition:\n    *   `if(n1 == len || n0 == len)`: This condition is true if *all* characters in the string were '1's (meaning `n1` equals the total `len`) OR if *all* characters were '0's (meaning `n0` equals the total `len`).\n    *   If the condition is true, \"YES\" is printed; otherwise, \"NO\" is printed. This accurately determines if the string is monochromatic ('0's only or '1's only).",
      "answer_source": "generated",
      "chapter": "Unit 3: Built-inString Functions: atoi, strlen, strcat, strcmp"
    },
    {
      "question_number": "13",
      "question_text": "Sajid is a graduate student he applied to a BPO company but he does not get typing fast. So he wanted to increase his typing speed for the job.\nHis well-wisher suggested that he type the sentence \"The quick brown fox jumps over the lazy dog\"repeatedly.\nThis sentence is known as a pangram because it contains every letter of the alphabet.\nAfter typing this sentence several times, Sajid needs to check whether the given numeric is a pangram .can you help him, whether the given sentence is a pangram or not\n#include <stdio.h>\n#include<stdlib.h>\n#include <string.h>\nint findpan();\nvoid findpan(char arr[])\n{\nint count[26]={0};\nint j;strlen(arr);\nfor(j=0;j<strlen(arr);j++)\ncount[arr[j]-'a']+=1;\nfor(j=0;j<26;j++)\nif(count[j]==0)\nbreak;\nif(j==26)\nprintf(\"pangram\");\nelse\nprintf(\"not a pangram\");\n}\nint main()\n{\nchar str[50];\nfgets(str,50,stdin);\nfindpan(str);\nreturn 0;\n}",
      "marks": 25,
      "answer": "The provided code attempts to check if a given string is a pangram (contains every letter of the alphabet). It has several issues:\n1.  **Function Prototype Mismatch**: The function `findpan` is prototyped as `int findpan()` but defined as `void findpan(char arr[])`. The return type and parameters do not match.\n2.  **`strlen` Usage**: `strlen(arr);` is called without its return value being stored or used, and it's called repeatedly in the loop condition, which is inefficient. The string length should be calculated once and stored in a variable.\n3.  **Case Sensitivity**: The current code `count[arr[j]-'a']` assumes all input characters are lowercase. A pangram check typically needs to be case-insensitive, converting all characters to a single case (e.g., lowercase) before counting.\n4.  **Non-alphabetic characters**: The current code will lead to out-of-bounds access for `count` array if `arr[j]` is not a lowercase alphabet, e.g., space or punctuation.\n\nHere is the corrected and explained program:\n\n```c\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h> // For tolower() function\n\n// Function to check if a string is a pangram\nvoid checkPangram(char *str)\n{\n    // A boolean array to mark presence of each alphabet (a-z)\n    int alphabetPresent[26] = {0}; // Initialize all to 0 (false)\n    int count = 0;                   // Count of unique alphabets found\n    int len = strlen(str);           // Get string length once\n\n    // Iterate through the string\n    for (int i = 0; i < len; i++)\n    {\n        // Convert character to lowercase to handle case-insensitivity\n        char ch = tolower(str[i]);\n\n        // Check if the character is a lowercase alphabet\n        if (ch >= 'a' && ch <= 'z')\n        {\n            // If this alphabet hasn't been marked yet, mark it and increment count\n            if (alphabetPresent[ch - 'a'] == 0)\n            {\n                alphabetPresent[ch - 'a'] = 1;\n                count++;\n            }\n        }\n    }\n\n    // If count of unique alphabets is 26, it's a pangram\n    if (count == 26)\n    {\n        printf(\"The sentence is a pangram.\\n\");\n    }\n    else\n    {\n        printf(\"The sentence is not a pangram.\\n\");\n    }\n}\n\nint main()\n{\n    char str[1000]; // Increased buffer size for longer sentences\n\n    printf(\"Enter a sentence to check for pangram: \");\n    // Use fgets to read potentially multiple words including spaces\n    fgets(str, sizeof(str), stdin);\n\n    // Remove trailing newline character if present from fgets\n    str[strcspn(str, \"\\n\")] = 0;\n\n    checkPangram(str);\n\n    return 0;\n}\n```\n\n**Explanation:**\n1.  **`checkPangram` Function**: This function takes a `char* str` (the sentence) as input.\n    *   **`alphabetPresent` array**: An integer array `alphabetPresent[26]` is used as a frequency map or a set. Each index `0` to `25` corresponds to 'a' through 'z'. It's initialized to `0`.\n    *   **Iteration and Conversion**: The function iterates through each character of the input string. `tolower(str[i])` converts the character to lowercase, making the check case-insensitive.\n    *   **Alphabet Check and Marking**: It checks if the character is an alphabet (`ch >= 'a' && ch <= 'z'`). If it is, `alphabetPresent[ch - 'a']` is set to `1` (marking that alphabet as present). `count` tracks how many *unique* alphabets have been found.\n    *   **Pangram Determination**: After checking all characters, if `count` is exactly `26` (meaning all 26 alphabets were found), the sentence is a pangram. Otherwise, it's not.\n2.  **`main` Function**: \n    *   Declares a `char` array `str` to store the input sentence.\n    *   Uses `fgets` to read the sentence. `fgets` is preferred over `scanf(\"%s\")` for sentences as it can read spaces.\n    *   Removes the trailing newline character that `fgets` might include.\n    *   Calls `checkPangram` to perform the analysis and print the result.",
      "answer_source": "generated",
      "chapter": "Unit 3: Function prototype declaration, function definition"
    },
    {
      "question_number": "14",
      "question_text": "Janu and Ram are close friends who talk a lot about life. They go through a lot of inspiring \"Quotes of Life\". One fine day they had a small game. According to the game, Ram will read one of the quotes about life from the book and Jannu has to think a word about life in her mind without disclosing it to Ram. Finally, once Ram completes reading the quote, Jannu will say if the word she thought in her mind is there in the quote read by Ram. Can you convert the same scenario to a programming logic? If the word thought by Jannu was present in the quote then you have to print \"Exists\" else print \"Doesn't Exist\".\n#include <stdio.h>\n#include <string.h>\nint main()\n{\n    int t;\n    scanf(\"%d\", &t);\n    while (t--)\n    {\n        char string[100];\n        char p[100];\n        scanf(\"%s %s\", string, p);\n        int M = strlen(p);\n        int N = strlen(string);\n        int res = 0;\n        for (int i = 0; i <= N - M; i++)\n        {\n            int j;\n            for (j = 0; j < M; j++)\n            {\n                if (string[i + j] != p[j])\n                    break;\n            }\n            if (j == M)\n            {\n                res++;\n                break; // Only need to check existence, so break after first match\n            }\n        }\n        if (res > 0)\n            printf(\"Exists\\n\");\n        else\n            printf(\"Doesn't Exist\\n\");\n    }\n    return 0;\n}",
      "marks": 25,
      "answer": "The problem asks to check if a \"word\" (substring `p`) is present within a \"quote\" (main string `string`). The provided code implements a basic brute-force substring search algorithm. There are some structural issues:\n1.  **Global Variables**: `M, N, i, j, res` are declared as global variables, which is generally discouraged for local scope variables as it can lead to unintended side effects. They should be local to `main` or the function performing the search.\n2.  **Unnecessary Braces**: There are extra curly braces `{}` in the `while` loop.\n3.  **`scanf(\"%s%s\", string, p)`**: This reads two words separated by whitespace. If the quote contains spaces, only the first word will be read into `string`. `fgets` would be more appropriate for reading a \"quote\".\n4.  **`j=0;` in `if(j==M)`**: This `j=0;` is unnecessary as `j` will be re-initialized by the inner `for` loop in the next iteration of the outer loop.\n\nHere is the corrected and explained program:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\n// Function to check if a substring (word) exists in a main string (quote)\nint isSubstringPresent(const char *quote, const char *word)\n{\n    int quoteLen = strlen(quote);\n    int wordLen = strlen(word);\n\n    // If the word is longer than the quote, it cannot be a substring\n    if (wordLen == 0) return 1; // Empty string is always a substring\n    if (wordLen > quoteLen) return 0;\n\n    // Iterate through the quote to find a potential starting point for the word\n    for (int i = 0; i <= quoteLen - wordLen; i++)\n    {\n        int match = 1; // Assume a match until proven otherwise\n        // Compare characters from the current position in quote with the word\n        for (int j = 0; j < wordLen; j++)\n        {\n            if (quote[i + j] != word[j])\n            {\n                match = 0; // Mismatch found\n                break;     // Exit inner loop\n            }\n        }\n        if (match) // If inner loop completed without mismatch, word is found\n        {\n            return 1; // Word exists\n        }\n    }\n    return 0; // Word does not exist after checking all positions\n}\n\nint main()\n{\n    int t; // Number of test cases\n    printf(\"Enter the number of test cases: \");\n    scanf(\"%d\", &t);\n\n    // Consume the newline character after reading t\n    while (getchar() != '\\n');\n\n    while(t--) // Loop through each test case\n    {\n        char quote[200]; // Increased size for quote, assuming it might contain spaces\n        char word[100];\n\n        printf(\"Enter the quote (sentence, use underscores for spaces if single word expected by scanf): \");\n        // Using fgets for quotes that might contain spaces\n        fgets(quote, sizeof(quote), stdin);\n        quote[strcspn(quote, \"\\n\")] = 0; // Remove trailing newline\n\n        printf(\"Enter the word Jannu thought: \");\n        fgets(word, sizeof(word), stdin);\n        word[strcspn(word, \"\\n\")] = 0; // Remove trailing newline\n\n        if(isSubstringPresent(quote, word))\n        {\n            printf(\"Exists\\n\");\n        }\n        else\n        {\n            printf(\"Doesn't Exist\\n\"); // Corrected spelling\n        }\n    }\n\n    return 0;\n}\n```\n\n**Explanation:**\n1.  **`isSubstringPresent` Function**: This function takes two `const char*` arguments: `quote` and `word`. \n    *   It first gets the lengths of both strings. It handles edge cases where the `word` is empty or longer than the `quote`.\n    *   The outer loop (`for (int i = 0; i <= quoteLen - wordLen; i++)`) iterates through all possible starting positions for `word` within `quote`.\n    *   The inner loop (`for (int j = 0; j < wordLen; j++)`) compares characters of `word` with the corresponding characters in `quote` starting from `quote[i]`. \n    *   If a mismatch `(quote[i + j] != word[j])` is found, `match` is set to `0`, and the inner loop breaks. \n    *   If the inner loop completes without a mismatch (`match` remains `1`), it means the `word` has been found, and the function returns `1`.\n    *   If the outer loop completes without finding any match, the function returns `0`.\n2.  **`main` Function**: \n    *   Reads the number of test cases `t`.\n    *   Inside the `while(t--)` loop, it reads the `quote` and `word` using `fgets` to properly handle spaces within sentences. `strcspn` is used to remove the newline character captured by `fgets`.\n    *   Calls `isSubstringPresent` to check for the word's presence and prints \"Exists\" or \"Doesn't Exist\" accordingly.",
      "answer_source": "generated",
      "chapter": "Unit 3: Built-inString Functions: atoi, strlen, strcat, strcmp"
    },
    {
      "question_number": "15",
      "question_text": "Jimmy and Jill are playing a string game. Jack has given Jill one string X. Jill has to give some characters to Jimmy, so he wants to display elements AB from string X. Jill needs help to do this task. He wants a program to do this as he is lazy. For example, if you consider input string X as ABFINALAB andyourOutput String Y is ABAB.\n#include <stdio.h>\nint main(void)\n{\nchar str[] = \"ABFINALAB\";\nchar outstr[strlen(str)+1];\nint i = 0, k = 0;\nwhile (str[i])\n{\nif (str[i] == 'B' || str[i] == 'A'))\n{\noutstr[k++] = str[i];\n}\ni++\n}\noutstr[k] = '\\0';\nprintf(\"The string with only A's and B's is %s\", outstr);\nreturn 0;\n}",
      "marks": 25,
      "answer": "The provided code correctly extracts 'A' and 'B' characters from a given string `str` and stores them in `outstr`. There's a minor syntax error in the `if` condition: `str[i] == 'A'))` has an extra closing parenthesis. Also, `strlen` needs to be included for `strlen(str)` to work.\n\nHere is the corrected and explained program:\n\n```c\n#include <stdio.h>\n#include <string.h> // Required for strlen()\n\nint main(void)\n{\n    char str[] = \"ABFINALAB\"; // Input string\n    // outstr size should be strlen(str) + 1 for the null terminator\n    char outstr[strlen(str) + 1]; \n    \n    int i = 0; // Index for iterating through str\n    int k = 0; // Index for adding characters to outstr\n\n    // Loop through the input string until the null terminator is reached\n    while (str[i] != '\\0') // Condition for while loop\n    {\n        // Check if the current character is 'A' or 'B'\n        if (str[i] == 'B' || str[i] == 'A') // Corrected: removed extra parenthesis\n        {\n            outstr[k++] = str[i]; // Add the character to outstr and increment k\n        }\n        i++; // Move to the next character in str\n    }\n\n    outstr[k] = '\\0'; // Null-terminate the output string\n\n    printf(\"The string with only A's and B's is: %s\\n\", outstr);\n\n    return 0;\n}\n```\n\n**Explanation:**\n1.  **Initialization**: An input string `str` is defined. An output string `outstr` is declared with a size large enough to hold all characters from `str` plus the null terminator. `i` and `k` are initialized as index counters for `str` and `outstr`, respectively.\n2.  **`while` Loop**: The `while (str[i] != '\\0')` loop iterates through each character of the `str` array until the null terminator `\\0` is encountered, which marks the end of the string.\n3.  **Conditional Check**: Inside the loop, `if (str[i] == 'B' || str[i] == 'A')` checks if the current character `str[i]` is either 'A' or 'B'.\n4.  **Extraction**: If the condition is true, the character `str[i]` is copied to `outstr[k]`, and then `k` is incremented (`k++`) to point to the next available position in `outstr`.\n5.  **Iteration**: After the conditional check, `i` is incremented (`i++`) to move to the next character in the `str` array.\n6.  **Null Termination**: After the loop finishes, `outstr[k] = '\\0';` adds a null terminator to the end of `outstr`, making it a valid C string.\n7.  **Output**: The resulting `outstr` containing only 'A's and 'B's is then printed.",
      "answer_source": "generated",
      "chapter": "Unit 3: String Basics - String Declaration and Initialization"
    },
    {
      "question_number": "16",
      "question_text": "There are n steps in a staircase. Write a C program using the two functions which reads the number of stair cases taken by the person as n and computes and prints all the ways to reach the top level from ground level (step 0).\n(Assumed that person can climb only one or two steps at a time)\n#include <stdio.h>\nint calc(int n);\nint count(int x);\nint main ()\n{\nint n;\nprintf(\"Enter number of stairs : \");\nscanf(\"%d\", &n);\nprintf(\"Number of ways = %d\", calc(n));\ngetchar();\nreturn 0;\n}\nint calc(int n)\n{\nif (n <= 1)\nreturn n;\nreturn calc(n-1) + calc(n-2);\n}",
      "marks": 25,
      "answer": "The provided code correctly solves the staircase problem (number of ways to climb `n` stairs by taking 1 or 2 steps) using recursion, which directly maps to the Fibonacci sequence. The function `count(int x);` is declared but never defined or used, so it can be removed. The `getchar();` after `printf` is likely intended to pause the console, but it's not strictly necessary for the core logic.\n\nHere is the cleaned-up and explained program:\n\n```c\n#include <stdio.h>\n\n// Function prototype for calculating ways to climb stairs\nint calc(int n);\n\nint main()\n{\n    int n; // Variable to store the number of stairs\n\n    printf(\"Enter number of stairs : \");\n    scanf(\"%d\", &n);\n\n    // Input validation: number of stairs should be non-negative\n    if (n < 0) {\n        printf(\"Number of stairs cannot be negative.\\n\");\n        return 1; // Indicate an error\n    }\n\n    // Call the recursive function to calculate the number of ways\n    int numberOfWays = calc(n);\n\n    printf(\"Number of ways to climb %d stairs = %d\\n\", n, numberOfWays);\n\n    // getchar(); // This line is often used to pause the console in some environments.\n                 // It's not part of the core logic and can be removed.\n\n    return 0;\n}\n\n// Recursive function to calculate the number of ways to climb n stairs\n// where a person can climb 1 or 2 steps at a time.\nint calc(int n)\n{\n    // Base cases:\n    // If there are 0 stairs, there's 1 way (do nothing).\n    // If there is 1 stair, there's 1 way (take 1 step).\n    if (n <= 1)\n    {\n        return n; // This works for n=0 (returns 0, if interpreted as 0 ways), and n=1 (returns 1 way).\n                  // For n=0, it's typically 1 way (do nothing). For n=0, the typical fibonacci sequence F(0)=0, F(1)=1. For staircase, it's often F(0)=1, F(1)=1. Let's adjust for n=0 for clarity.\n    }\n    \n    // Recursive step:\n    // The number of ways to reach stair n is the sum of:\n    // 1. Ways to reach stair (n-1) and then take 1 step.\n    // 2. Ways to reach stair (n-2) and then take 2 steps.\n    return calc(n-1) + calc(n-2);\n}\n```\n\n**Note on Base Cases for `calc(int n)`:**\nThe common interpretation for `n` stairs, where `F(n)` is the number of ways:\n*   `F(0) = 1` (one way to reach 0 steps: do nothing)\n*   `F(1) = 1` (one way to reach 1 step: take 1 step)\n*   `F(n) = F(n-1) + F(n-2)` for `n > 1`.\n\nThe provided `if (n <= 1) return n;` would return `0` for `n=0` and `1` for `n=1`. If the interpretation for `n=0` is `1` way, the base case should be slightly adjusted for `n=0` to `return 1;`.\n\n**Adjusted `calc` base cases for `n=0` being 1 way:**\n```c\nint calc(int n)\n{\n    if (n == 0) return 1; // One way to be at ground level (do nothing)\n    if (n == 1) return 1; // One way to climb 1 stair\n    return calc(n-1) + calc(n-2);\n}\n```\nGiven the provided code returns `n` for `n <= 1`, it will return `0` for `n=0`. If `n=0` is not expected input, the given base cases are effectively correct for `n >= 1`.\n\n**Explanation of Current Logic:**\n1.  **`main` Function**: Prompts the user to enter the number of stairs `n`, then calls the `calc` function with `n` and prints the returned result.\n2.  **`calc` Function (Recursive)**:\n    *   **Base Cases**: \n        *   If `n` is `0` (or less), it returns `0`. (This assumes 0 stairs has 0 ways, if 1 way is intended, base case needs adjustment as discussed above).\n        *   If `n` is `1`, it returns `1` (there's only one way: take one step).\n    *   **Recursive Step**: For `n > 1`, the function calculates the number of ways by summing two possibilities:\n        *   `calc(n-1)`: The number of ways to reach stair `n` by taking a single step from stair `n-1`.\n        *   `calc(n-2)`: The number of ways to reach stair `n` by taking a double step from stair `n-2`.\n    This recursive relation mirrors the Fibonacci sequence, where each term is the sum of the two preceding ones.",
      "answer_source": "generated",
      "chapter": "Unit 3: Function prototype declaration, function definition"
    },
    {
      "question_number": "17",
      "question_text": "Netflix announced a one-year subscription offer for technical students. It will provide two numbers for the addition using call by reference. If the answer is correct for this question, you will get the offer. Can you complete the task to win this competition?\n#include <stdio.h>\nint addTwoNumbers(int *n1,int *n2){return(*n1+*n2);}\nint main()\n{\nint *ptr,\n*qtr, first, second;\nscanf(\"%d%d\", &first, &second);\nprintf(\"%d\", addTwoNumbers(&first, &second));\nreturn(0);\n}",
      "marks": 25,
      "answer": "The provided code correctly demonstrates the concept of \"call by reference\" for passing arguments to a function to perform addition. The function `addTwoNumbers` receives pointers to integers and dereferences them to access their values. The `main` function then passes the addresses of `first` and `second` to this function.\n\nHere is the explained program:\n\n```c\n#include <stdio.h>\n\n// Function that accepts two integer pointers and returns their sum\n// This demonstrates 'call by reference' as it uses addresses\nint addTwoNumbers(int *n1_ptr, int *n2_ptr) {\n    // Dereference the pointers to get the values and then add them\n    return (*n1_ptr + *n2_ptr);\n}\n\nint main()\n{\n    // Declaring variables to store the two numbers\n    int first, second;\n    // Declaring pointers, though not directly used to call the function in this specific snippet,\n    // they illustrate the concept of pointers which is central to call by reference.\n    // int *ptr, *qtr; // These are declared but unused, can be removed if not needed.\n\n    printf(\"Enter the first number: \");\n    scanf(\"%d\", &first); // Read the first number\n\n    printf(\"Enter the second number: \");\n    scanf(\"%d\", &second); // Read the second number\n\n    // Call addTwoNumbers function by passing the addresses of 'first' and 'second'.\n    // This is 'call by reference' because the function works with the memory locations.\n    int sum = addTwoNumbers(&first, &second);\n\n    printf(\"The sum of %d and %d is: %d\\n\", first, second, sum);\n\n    return 0;\n}\n```\n\n**Explanation:**\n1.  **`addTwoNumbers` Function**: \n    *   It is defined to take two arguments: `int *n1_ptr` and `int *n2_ptr`. These are pointers, meaning they will receive memory addresses, not the actual values themselves.\n    *   Inside the function, `*n1_ptr` and `*n2_ptr` are used to *dereference* the pointers. Dereferencing means accessing the value stored at the memory address pointed to by the pointer. The function then adds these dereferenced values and returns their sum.\n2.  **`main` Function**: \n    *   It declares two integer variables, `first` and `second`.\n    *   It prompts the user to input values for `first` and `second` using `scanf`.\n    *   When calling `addTwoNumbers`, it passes `&first` and `&second`. The `&` (address-of) operator provides the memory address of the variables `first` and `second` to the function. This is the essence of \"call by reference\"  instead of passing copies of the values, the function works directly with the original variables' memory locations.\n    *   The returned sum is then printed.",
      "answer_source": "generated",
      "chapter": "Unit 3: Call by Value, Call by Reference"
    },
    {
      "question_number": "18",
      "question_text": "Amal has given an array a1, a2,...,an to Abdul. Write a Program to print whether the array is pairwise distinct using function concepts\n#include <stdio.h>\nint isDistinct(char* a, int sz)\n{\nfor(int i = 0; i < sz - 1; i++)\nfor(int j = i+1; j < sz; j++)\nif(a[i] == a[j])\nreturn(0);\nreturn(1);\n}\nint main()\n{\nint i, n;\nprintf(\"Enter size of array:\");\nscanf(\"%d\", &n);\nint a[n];\nfor(i = 0; i < n; i++)\nscanf(\"%d\", &a[i]);\nint check = isDistinct(a, n);\nif(check)\nprintf(Distinct\\n);\nelse\nprintf(\"Not distinct\\n\");\n}",
      "marks": 25,
      "answer": "The provided code aims to check if all elements in an array are distinct using a function. It correctly uses nested loops to compare all pairs of elements. However, there is a critical type mismatch:\n1.  **Type Mismatch in Function Signature**: The `isDistinct` function is defined as `int isDistinct(char* a, int sz)`, expecting a pointer to `char`. But in `main`, an `int` array `int a[n];` is declared, and its address (`a`) is passed to `isDistinct`. When an `int` array is passed to a `char*` parameter, the function will misinterpret the data, potentially leading to incorrect comparisons or memory access errors. The function signature should be `int isDistinct(int* a, int sz)`.\n2.  **Smart Quotes**: The `printf` statements in `main` use smart quotes (`Distinct\\n`, `Not distinct\\n`) which are not standard C syntax and would cause a compilation error.\n\nHere is the corrected and explained program:\n\n```c\n#include <stdio.h>\n\n// Function to check if elements in an integer array are pairwise distinct\n// Corrected: takes an int* (pointer to int) for the array\nint isDistinct(int* arr, int sz)\n{\n    // Iterate through all elements up to the second to last element\n    for(int i = 0; i < sz - 1; i++)\n    {\n        // Compare the current element (arr[i]) with all subsequent elements (arr[j])\n        for(int j = i + 1; j < sz; j++)\n        {\n            // If any two elements are found to be equal, the array is not distinct\n            if(arr[i] == arr[j])\n            {\n                return 0; // Return 0 (false) immediately if a duplicate is found\n            }\n        }\n    }\n    // If no duplicates were found after checking all pairs, the array is distinct\n    return 1; // Return 1 (true)\n}\n\nint main()\n{\n    int n; // Variable to store the size of the array\n\n    printf(\"Enter size of array: \");\n    scanf(\"%d\", &n);\n\n    // Input validation\n    if (n <= 0) {\n        printf(\"Array size must be positive.\\n\");\n        return 1;\n    }\n\n    int a[n]; // Declare a variable-length array (VLA) of integers\n\n    printf(\"Enter %d integer elements:\\n\", n);\n    for(int i = 0; i < n; i++) // Loop to read array elements\n    {\n        scanf(\"%d\", &a[i]);\n    }\n\n    // Call the isDistinct function, passing the array and its size\n    // When an array name is passed to a function, it decays to a pointer to its first element.\n    int check = isDistinct(a, n);\n\n    if(check) // If check is 1 (true)\n    {\n        printf(\"Distinct\\n\"); // Corrected: standard quotes\n    }\n    else // If check is 0 (false)\n    {\n        printf(\"Not distinct\\n\"); // Corrected: standard quotes\n    }\n\n    return 0;\n}\n```\n\n**Explanation:**\n1.  **`isDistinct` Function**: \n    *   It now correctly takes `int* arr` as its first argument, matching the `int` array type from `main`.\n    *   It uses nested `for` loops to compare every element `arr[i]` with every subsequent element `arr[j]` (where `j` starts from `i+1`). This ensures each pair is compared exactly once.\n    *   If `arr[i] == arr[j]` for any pair, it means a duplicate is found, and the function immediately returns `0` (false).\n    *   If the loops complete without finding any duplicates, the function returns `1` (true), indicating all elements are distinct.\n2.  **`main` Function**: \n    *   Prompts the user for the array size `n` and then reads `n` integer elements into the `a` array.\n    *   It then calls `isDistinct(a, n)`, passing the array `a` (which decays to a pointer to its first element) and its size `n`.\n    *   Based on the return value of `isDistinct`, it prints whether the array is \"Distinct\" or \"Not distinct\".",
      "answer_source": "generated",
      "chapter": "Unit 3: Passing Array to Function"
    },
    {
      "question_number": "19",
      "question_text": "Sameer wants a number plate for his Brand new luxury bike. He likes it to be unrepeatable.\nHe came through a display board about the Fibonacci series. He wants to check whether the number he wants to use for his bike comes in the Fibonacci series or not.\nCan you help him with a program which checks if a number is present in the Fibonacci series or not using a function.\nFibonacci Series example:0 1 2 3 5 8.....that means initial values are 0 and 1 next value will be calculated by adding previous two values and so on..\n#include <stdio.h>\n#include <math.h>\nint isPerfectSquare(long x)\n{\n    int s = (int)sqrt(x);\n    return (s * s == x);\n}\nint isFibonacci(int x)\n{\n    return isPerfectSquare(5 * x * x + 4) || isPerfectSquare(5 * x * x - 4);\n}\nint main()\n{\n    int n;\n    scanf(\"%d\", &n);\n    if (isFibonacci(n))\n        printf(\"YES\");\n    else\n        printf(\"NO\");\n    return 0;\n}",
      "marks": 25,
      "answer": "The provided code correctly implements a mathematical property to check if a given number is a Fibonacci number. The property states that a positive integer `x` is a Fibonacci number if and only if `5x^2 + 4` or `5x^2 - 4` is a perfect square. The code uses `isPerfectSquare` and `isFibonacci` functions to apply this property. The `main` function then utilizes these functions to check user input.\n\nHere is the explained program:\n\n```c\n#include <stdio.h>\n#include <math.h> // Required for sqrt() function\n\n// Function to check if a number is a perfect square\nint isPerfectSquare(long long x)\n{\n    if (x < 0) return 0; // Negative numbers cannot be perfect squares\n    long long s = (long long)sqrt(x); // Calculate the integer part of the square root\n    return (s * s == x); // Check if the square of s equals x\n}\n\n// Function to check if a number is a Fibonacci number\n// A number 'n' is Fibonacci if (5*n*n + 4) or (5*n*n - 4) is a perfect square\nint isFibonacci(int n)\n{\n    if (n < 0) return 0; // Fibonacci numbers are non-negative\n    if (n == 0 || n == 1) return 1; // 0 and 1 are Fibonacci numbers by definition\n\n    // Apply the mathematical property\n    return isPerfectSquare(5LL * n * n + 4) || isPerfectSquare(5LL * n * n - 4);\n    // Using 5LL ensures the multiplication is done using long long to prevent overflow\n}\n\nint main()\n{\n    int n; // Variable to store the user-entered number\n\n    printf(\"Enter a number to check if it's a Fibonacci number: \");\n    scanf(\"%d\", &n);\n\n    if(isFibonacci(n))\n    {\n        printf(\"YES, %d is a Fibonacci number.\\n\", n);\n    }\n    else\n    {\n        printf(\"NO, %d is not a Fibonacci number.\\n\", n);\n    }\n\n    return 0;\n}\n```\n\n**Explanation:**\n1.  **`isPerfectSquare` Function**: \n    *   Takes a `long long` integer `x` as input.\n    *   It first handles negative inputs, returning `0` as they cannot be perfect squares.\n    *   It calculates the integer square root of `x` using `sqrt()` (which returns a `double`) and casts it to `long long`. The `long long` type is used to prevent potential overflow for larger `x` values in `5*x*x`.\n    *   It then checks if `s * s` is exactly equal to `x`. If it is, `x` is a perfect square, and the function returns `1` (true); otherwise, it returns `0` (false).\n2.  **`isFibonacci` Function**: \n    *   Takes an integer `n` as input.\n    *   It handles base cases: `0` and `1` are explicitly defined as Fibonacci numbers.\n    *   For `n > 1`, it applies the mathematical property: it checks if `(5 * n * n + 4)` OR `(5 * n * n - 4)` is a perfect square by calling `isPerfectSquare`.\n    *   `5LL * n * n` is used to ensure that the intermediate product `5 * n * n` is computed as a `long long` to avoid overflow before being passed to `isPerfectSquare`.\n3.  **`main` Function**: \n    *   Prompts the user to enter a number `n`.\n    *   Calls the `isFibonacci` function with `n`.\n    *   Based on the boolean result, it prints \"YES\" or \"NO\" to indicate whether the number is a Fibonacci number.",
      "answer_source": "generated",
      "chapter": "Unit 3: Function prototype declaration, function definition"
    },
    {
      "question_number": "20",
      "question_text": "Arif and Selvan both are friends. Both are planning to utilize the vacation holidays by learning a programming language. They learned the concept of the pointer and want to know the knowledge level. So they decided to make a coding test for each other. Arif wrote a string in the paper. Selvan wants to identify the total length of the input. Can you help Selvan by writing a program with the help of function and pointer concept without using predefined string functions?\n#include <stdio.h> #include <string.h>\nint calculateLength(char* ch){\nfor(int i = 0; ch[i] != '\\0'; i++);\nreturn i;\n}\nint main()\n{\nchar a[151];\nscanf(\"%s\",a);\nprintf(\"%d\",calculateLength(a));\nreturn 0;\n}",
      "marks": 25,
      "answer": "The provided code correctly calculates the length of a string using a user-defined function and pointer concept, without relying on the standard library's `strlen` function. The `calculateLength` function iterates through the characters of the string until it encounters the null terminator `\\0`, counting the characters along the way. The `string.h` header is included but not strictly necessary since `strlen` is not used.\n\nHere is the explained program:\n\n```c\n#include <stdio.h>\n// #include <string.h> is not strictly necessary as strlen() is not used\n\n// Function to calculate the length of a string using a pointer\nint calculateLength(char* str_ptr) {\n    int count = 0; // Initialize a counter for the length\n\n    // Iterate through the string using the pointer until the null terminator is found\n    // The loop body is empty as the increment happens in the condition\n    for (count = 0; str_ptr[count] != '\\0'; count++);\n\n    return count; // Return the final count (which is the length)\n}\n\nint main()\n{\n    char inputString[151]; // Declare a character array (string) to hold the input\n\n    printf(\"Enter a string (max 150 characters, no spaces for scanf): \");\n    scanf(\"%s\", inputString); // Read the string into inputString\n\n    // Call the custom calculateLength function, passing the array name (which decays to a pointer)\n    int length = calculateLength(inputString);\n\n    printf(\"The length of the string \\\"%s\\\" is: %d\\n\", inputString, length);\n\n    return 0;\n}\n```\n\n**Explanation:**\n1.  **`calculateLength` Function**: \n    *   Takes a `char* str_ptr` as input. This pointer points to the first character of the string.\n    *   It uses a `for` loop. The loop's initialization `count = 0;` sets the length counter.\n    *   The loop's condition `str_ptr[count] != '\\0'` checks if the character at the current `count` index is not the null terminator. Strings in C are null-terminated, meaning `\\0` marks their end.\n    *   The loop's increment `count++` moves to the next character. The loop has an empty body (`;`) because all the work (checking and incrementing the counter) is done in the loop header.\n    *   When the loop finishes (meaning `\\0` is encountered), `count` will hold the number of characters before the null terminator, which is the string's length. This value is then returned.\n2.  **`main` Function**: \n    *   Declares a character array `inputString` to store the user's input.\n    *   Prompts the user to enter a string and reads it using `scanf(\"%s\", inputString)`. Note: `scanf(\"%s\")` reads a single word (stops at whitespace). For strings with spaces, `fgets` would be more appropriate.\n    *   It then calls `calculateLength(inputString)`. When `inputString` (an array name) is passed as an argument, it automatically \"decays\" into a pointer to its first element, thus fulfilling the `char*` parameter requirement of the function.\n    *   The returned `length` is then printed.",
      "answer_source": "generated",
      "chapter": "Unit 3: Function prototype declaration, function definition"
    }
  ]
}