{
    "paper_title": "CT question paper 2024 PPS - Programming For Problem Solving",
    "source": "2024-12-10 CT2 Set3",
    "questions": [
        {
            "question_number": "1",
            "question_text": "What is the output of the following code?\nchar str[10] = \"C Programming\";\nprintf(\"%c\", str[3]);\nA) C\nB) P\nC) r\nD) o",
            "marks": 1,
            "answer": "The string \"C Programming\" is stored as a character array. In C, arrays are 0-indexed. Therefore, `str[3]` refers to the character at the fourth position in the string. Counting from 0:\n- `str[0]` is 'C'\n- `str[1]` is ' '\n- `str[2]` is 'P'\n- `str[3]` is 'r'\nSo, the `printf(\"%c\", str[3]);` statement will print the character 'r'.\nThe correct option is C.",
            "answer_source": "generated",
            "chapter": "Unit 1: Evolution of Programming & Languages - Non-Numeric Data types: char and string"
        },
        {
            "question_number": "2",
            "question_text": "What will atoi(\"1234\") return?\nA) \"1234\"\nB) 1234\nC) 12\nD) An error",
            "marks": 1,
            "answer": "The `atoi()` function (ASCII to Integer) is a standard library function in C that converts a string (null-terminated character array) representation of an integer to its integer equivalent. When passed the string \"1234\", it will convert it into the integer value 1234.\nThe correct option is B.",
            "answer_source": "generated",
            "chapter": "Unit 3: String Basics - Built-inString Functions: atoi"
        },
        {
            "question_number": "3",
            "question_text": "When an array is passed to a function, what information must be passed along with it to process the array within the function? (Select all that apply)\nA) Just the array name\nB) The array's size\nC) The data type of array elements\nD) A pointer to the last element",
            "marks": 1,
            "answer": "In C, when an array is passed to a function, the array name itself 'decays' into a pointer to its first element. This pointer does not carry information about the array's size. Therefore:\n-   **A) Just the array name**: This is essential as it provides the starting address of the array (a pointer to the first element).\n-   **B) The array's size**: This is crucial because the function needs to know how many elements to process to avoid accessing out-of-bounds memory. Without the size, the function cannot reliably iterate through the entire array.\n-   C) The data type of array elements: While important for pointer arithmetic, the type is typically defined in the function signature (e.g., `int *arr`), so it's implicitly known if the pointer type is correctly specified. It's not usually passed as a separate piece of information alongside the array name and size.\n-   D) A pointer to the last element: This is not a standard or necessary piece of information to pass. Knowing the start address and size is sufficient.\n\nTherefore, to properly process an array within a function, both the array name (which provides the base address) and the array's size must be passed. Options A and B are correct.",
            "answer_source": "generated",
            "chapter": "Unit 3: String Basics - Function prototype declaration, function definition - Passing Array to Function"
        },
        {
            "question_number": "4",
            "question_text": "Which of the following is a valid multi-line comment in Python?\nA) # This is a comment\nB)/* This is a comment */\nC) // This is a comment\nD) \"\"\" This is a comment \"\"\"",
            "marks": 1,
            "answer": "In Python:\n-   `#` is used for single-line comments.\n-   `/* */` is used for multi-line comments in languages like C, C++, and Java.\n-   `//` is used for single-line comments in languages like C++, Java, and JavaScript.\n-   `\"\"\"` (triple double quotes) or `'''` (triple single quotes) are used for multi-line strings, which can also serve as multi-line comments if not assigned to a variable.\n\nTherefore, the correct option is D.",
            "answer_source": "generated",
            "chapter": "Unit 4: Python: Introduction to Python - Python-Single and Multi-line Comments/ Error Handling"
        },
        {
            "question_number": "5",
            "question_text": "Which of the following statements about Python data types are correct? (Select all that apply)\nA) Python lists are mutable, meaning their elements can be modified after creation.\nB) Python tuples are mutable and can store elements of any data type.\nC) Strings in Python are immutable.\nD) Python dictionaries cannot have duplicate keys.",
            "marks": 1,
            "answer": "Let's evaluate each statement:\n-   **A) Python lists are mutable, meaning their elements can be modified after creation.** This statement is **correct**. Lists are dynamic and their contents can be changed, added, or removed.\n-   **B) Python tuples are mutable and can store elements of any data type.** This statement is **incorrect**. Tuples are immutable; once created, their elements cannot be changed, added, or removed. They can, however, store elements of any data type.\n-   **C) Strings in Python are immutable.** This statement is **correct**. Once a string is created, its characters cannot be changed in place. Any operation that appears to modify a string actually creates a new string.\n-   **D) Python dictionaries cannot have duplicate keys.** This statement is **correct**. Dictionary keys must be unique. If you try to assign a value to an existing key, it will overwrite the old value. Duplicate values are allowed, but not duplicate keys.\n\nTherefore, options A, C, and D are correct.",
            "answer_source": "generated",
            "chapter": "Unit 4: Python: Basic Data Types: Integers, Floating Points, Boolean types - Working with String functions - Working with List structures - Working with Tuples data structures - Working with Dictionaries"
        },
        {
            "question_number": "6",
            "question_text": "What will be the output of the following code? (MSQ)\nmy_dict={\"apple\": 3, \"banana\": 5}\nprint(my_dict.get(\"orange\", 0))\nA) 3\nB) 5\nC) 0\nD) None",
            "marks": 1,
            "answer": "The `get()` method of a Python dictionary is used to retrieve the value associated with a specified key. It takes two arguments: the key to search for and an optional default value. If the key is found, `get()` returns its corresponding value. If the key is not found, `get()` returns the default value provided.\n\nIn this code:\n-   `my_dict` is `{\"apple\": 3, \"banana\": 5}`.\n-   We are calling `my_dict.get(\"orange\", 0)`.\n-   The key \"orange\" is not present in `my_dict`.\n-   The default value provided is `0`.\n\nTherefore, the `get()` method will return `0`.\nThe correct option is C.",
            "answer_source": "generated",
            "chapter": "Unit 4: Python: Working with Dictionaries"
        },
        {
            "question_number": "7",
            "question_text": "What will be the shape of the following NumPy array?\nimport numpy as np\na = np.array([[1, 2, 3], [4, 5, 6]])\nprint(a.shape)\na)(6,)\nb)(3,2)\nc)(2,3)\nd) (3,)",
            "marks": 1,
            "answer": "The `np.array([[1, 2, 3], [4, 5, 6]])` creates a 2-dimensional NumPy array. It has two rows and three columns.\n-   The first dimension (rows) has a size of 2.\n-   The second dimension (columns) has a size of 3.\n\nThe `a.shape` attribute returns a tuple indicating the dimensions of the array. For this array, the shape will be (2, 3).\nThe correct option is C.",
            "answer_source": "generated",
            "chapter": "Unit 5: Creating NumPy Array - Numpy Array attributes"
        },
        {
            "question_number": "8",
            "question_text": "Which of the following are valid ways to create a NumPy array? (Select all that apply)\n(MSQ)\nA) np.array([1, 2, 3])\nB) np.zeros((3, 3))\nC) np.ones[3]\nD) np.arange(5)",
            "marks": 1,
            "answer": "Let's evaluate each option for creating NumPy arrays:\n-   **A) `np.array([1, 2, 3])`**: This is a **valid** way to create a NumPy array from a Python list.\n-   **B) `np.zeros((3, 3))`**: This is a **valid** way to create a 3x3 NumPy array filled with zeros. The `(3, 3)` tuple specifies the shape.\n-   **C) `np.ones[3]`**: This is **invalid**. `np.ones()` is a function that takes a shape as an argument (e.g., `np.ones(3)` for a 1D array of 3 ones, or `np.ones((3, 3))` for a 2D array). Using square brackets `[]` as if for indexing immediately after the function name is incorrect syntax for creation.\n-   **D) `np.arange(5)`**: This is a **valid** way to create a NumPy array with elements starting from 0 up to (but not including) 5, similar to Python's `range()` function.\n\nTherefore, options A, B, and D are correct.",
            "answer_source": "generated",
            "chapter": "Unit 5: Creating NumPy Array"
        },
        {
            "question_number": "9",
            "question_text": "Ms. Alice wants to create a program that reads a line of text, which may include spaces and tab characters (excluding newlines), and then prints the count of whitespace characters in the line. Write a program to accomplish this task.",
            "marks": 4,
            "answer": "```c\n#include <stdio.h>\n#include <string.h> // Required for strcspn to remove newline\n\nint main() {\n    char line[1000]; // Declare a character array to store the input line\n    int i, whitespace_count = 0;\n\n    printf(\"Enter a line of text: \");\n    // Using fgets to read a line including spaces and tabs\n    // fgets reads up to sizeof(line)-1 characters or until a newline is encountered.\n    // It includes the newline character if it fits in the buffer.\n    fgets(line, sizeof(line), stdin);\n\n    // Remove the trailing newline character if fgets captured it\n    // strcspn finds the first occurrence of newline or null terminator\n    line[strcspn(line, \"\\n\")] = 0;\n\n    // Iterate through the string to count whitespace characters\n    for (i = 0; line[i] != '\\0'; i++) {\n        if (line[i] == ' ' || line[i] == '\\t') { // Check for space or tab\n            whitespace_count++;\n        }\n    }\n\n    printf(\"Number of whitespace characters: %d\\n\", whitespace_count);\n\n    return 0;\n}\n```\n\n**Explanation:**\n1.  **Include Headers**: `stdio.h` for input/output functions (`printf`, `fgets`) and `string.h` for `strcspn` (used to remove the trailing newline from `fgets` input).\n2.  **Declare Variables**: `line` is a character array to store the input string. `whitespace_count` is an integer initialized to 0 to keep track of the count.\n3.  **Read Input**: `fgets(line, sizeof(line), stdin)` is used to read an entire line of text from the standard input (`stdin`). `fgets` is preferred over `scanf(\"%s\", ...)` for reading lines with spaces because `scanf` stops at the first whitespace. `sizeof(line)` ensures that the buffer overflow is prevented.\n4.  **Remove Newline**: `fgets` often includes the newline character (`\\n`) if there's space for it. `line[strcspn(line, \"\\n\")] = 0;` finds the position of the newline and replaces it with a null terminator (`\\0`), effectively removing it from the string.\n5.  **Count Whitespace**: A `for` loop iterates through each character of the `line` array until it encounters the null terminator (`\\0`), which marks the end of the string. Inside the loop, an `if` condition checks if the current character is either a space (`' '`) or a tab (`'\\t'`). If it is, `whitespace_count` is incremented.\n6.  **Print Result**: Finally, the program prints the total number of whitespace characters found.",
            "answer_source": "generated",
            "chapter": "Unit 3: String Basics - String Declaration and Initialization - String Functions: gets(), puts(), getchar(),putchar(), printf() - Operations on Strings"
        },
        {
            "question_number": "10",
            "question_text": "Write a Python code to create 2D array in NumPy. reshape it into a 3D array, and then demonstrate how to access a specific element in the reshaped 3D array.",
            "marks": 10,
            "answer": "```python\nimport numpy as np\n\n# 1. Create a 2D array in NumPy\n# We'll create a 4x3 2D array (4 rows, 3 columns)\nprint(\"--- Step 1: Creating a 2D Array ---\")\narray_2d = np.array([\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9],\n    [10, 11, 12]\n])\nprint(\"Original 2D Array:\")\nprint(array_2d)\nprint(\"Shape of 2D Array:\", array_2d.shape)\nprint(\"Total elements:\", array_2d.size)\n\n# 2. Reshape it into a 3D array\n# For a 2D array with 12 elements (4*3), we can reshape it into a 3D array\n# For example, a (2, 2, 3) shape: 2 'matrices', each with 2 rows and 3 columns.\n# The product of the new dimensions (2*2*3 = 12) must equal the total number of elements.\nprint(\"\\n--- Step 2: Reshaping to 3D Array ---\")\ntry:\n    array_3d = array_2d.reshape(2, 2, 3) # Reshape into 2 'blocks', each 2x3\n    print(\"Reshaped 3D Array (shape (2, 2, 3)):\")\n    print(array_3d)\n    print(\"Shape of 3D Array:\", array_3d.shape)\n\n    # 3. Demonstrate how to access a specific element in the reshaped 3D array\n    # In a 3D array, elements are accessed using three indices: [matrix_index, row_index, column_index]\n    print(\"\\n--- Step 3: Accessing Specific Elements ---\")\n\n    # Access the element at the first matrix (index 0), second row (index 1), third column (index 2)\n    # This corresponds to the value 6 in our example.\n    element_1 = array_3d[0, 1, 2]\n    print(f\"Element at array_3d[0, 1, 2]: {element_1}\")\n\n    # Access the element at the second matrix (index 1), first row (index 0), first column (index 0)\n    # This corresponds to the value 7 in our example.\n    element_2 = array_3d[1, 0, 0]\n    print(f\"Element at array_3d[1, 0, 0]: {element_2}\")\n\nexcept ValueError as e:\n    print(f\"Error reshaping array: {e}. Ensure the new shape is compatible with the number of elements.\")\n```\n\n**Explanation:**\n1.  **Create 2D Array**: We import `numpy` and use `np.array()` to create a 2D array named `array_2d` with 4 rows and 3 columns. Its `shape` is `(4, 3)`. The total number of elements is `4 * 3 = 12`.\n2.  **Reshape to 3D Array**: The `reshape()` method is called on `array_2d` to transform it into a 3D array. We provide the new desired shape as `(2, 2, 3)`. This means the array will have 2 \"matrices\" or \"blocks\", each containing 2 rows and 3 columns. The total number of elements `2 * 2 * 3 = 12` matches the original, which is a requirement for reshaping.\n3.  **Access Specific Element**: For a 3D array, indexing requires three coordinates: `[matrix_index, row_index, column_index]`. The example demonstrates accessing `array_3d[0, 1, 2]` which retrieves the element from the first matrix (index 0), second row (index 1), and third column (index 2). Another example `array_3d[1, 0, 0]` accesses the first element of the first row of the second matrix. This clearly shows how individual elements are pinpointed within the new 3D structure.",
            "answer_source": "generated",
            "chapter": "Unit 4: Python: Introduction to Numpy - High Dimensional Arrays"
        },
        {
            "question_number": "11",
            "question_text": "Write a Pandas program create number of lists of Series\ncombine them into a single Series\nSample Output\nOriginal Series of list\n0 Red\n1 Green\n2 White\n3 Red\n4 Black\n5 Yellow\nOne Series\n0 Red\n1 Green\n2 White\n3 Red\n4 Black\n5 Yellow",
            "marks": 10,
            "answer": "```python\nimport pandas as pd\n\n# 1. Create a number of lists of Series\n# Each list will be converted into a pandas Series object\nprint(\"Original Series of list:\")\nseries1 = pd.Series(['Red', 'Green', 'White'])\nprint(series1)\n\nseries2 = pd.Series(['Red', 'Black'])\nprint(series2)\n\nseries3 = pd.Series(['Yellow'])\nprint(series3)\n\n# Store these individual Series in a Python list for easier handling\nlist_of_series = [series1, series2, series3]\n\n# 2. Combine them into a single Series\n# pd.concat() function is used to concatenate Series or DataFrames.\n# By setting ignore_index=True, a new, clean integer index is generated for the combined Series.\nprint(\"\\nOne Series (combined):\")\none_series = pd.concat(list_of_series, ignore_index=True)\nprint(one_series)\n```\n\n**Explanation:**\n1.  **Creating Individual Series**: The program starts by importing the `pandas` library. It then creates three distinct `pd.Series` objects, each initialized with a list of strings (e.g., `['Red', 'Green', 'White']`). These individual Series are printed to show their initial state, matching the 'Original Series of list' from the sample output.\n2.  **Combining into a Single Series**: The `pd.concat()` function is used to join these multiple Series into one larger Series. The `list_of_series` contains all the Series to be concatenated. The `ignore_index=True` argument is crucial here; it tells `concat` to reset the index of the resulting Series, so it gets a fresh, continuous integer index starting from 0, rather than keeping the original indices from the individual Series. The final `one_series` object, which is the combined Series, is then printed, matching the 'One Series' section of the sample output.",
            "answer_source": "generated",
            "chapter": "Unit 5: Introduction to Pandas - Creating Series Objects, Data Frame Objects"
        },
        {
            "question_number": "12a",
            "question_text": "Mr. Adam is a software programmer at Orange Systems.\nHe wanted to assess the trainee's skillset in C language.\nHence, he has assigned some tasks to the trainees to\ncomplete in the allotted time. Assist them in completing\nthe tasks listed below.\n(i) Consider the fragment.\nchar str[]= \"I am Gr8DON\";\nstr[4]=\"10\";\nprintf(\"%s\", str);\nWhat will be the output? Justify the answer.\n(ii) Write a C program to find the length of a given string\nwithout using string functions.\nInput: \"Programming for Problem Solving\"",
            "marks": 10,
            "answer": "**(i) Analysis of the C code fragment:**\n\n```c\nchar str[]= \"I am Gr8DON\";\nstr[4]=\"10\";\nprintf(\"%s\", str);\n```\n\n**Output and Justification:**\nThis code will result in a **compilation error** (or a warning treated as an error by many compilers) due to incompatible types in the assignment `str[4] = \"10\";`.\n\n**Justification:**\n1.  `char str[] = \"I am Gr8DON\";` declares `str` as a character array (string) initialized with \"I am Gr8DON\". `str[4]` refers to the character at index 4, which is 'G' in the original string. This element is of type `char`.\n2.  `\"10\"` is a string literal. In C, string literals are arrays of characters (e.g., `{'1', '0', '\\0'}`). When used in an assignment context like this, it typically decays to a pointer (`char*`) to its first character. Attempting to assign a `char*` (pointer to char) to a `char` (single character) is a type mismatch. You cannot assign a multi-character string literal to a single `char` variable.\n\nTo correctly assign a character, single quotes should be used (e.g., `str[4] = '1';`). If the intention was to assign the single character '1', the code would be valid, and the output would be \"I am 1r8DON\". However, with `\"10\"`, it's an invalid operation.\n\n**Example of a common compiler error:**\n`error: incompatible types when assigning to type 'char' from type 'char [3]'` (or similar depending on the compiler and standard).\n\n--- \n\n**(ii) C program to find the length of a string without using string functions:**\n\n```c\n#include <stdio.h>\n\nint main() {\n    char str[] = \"Programming for Problem Solving\"; // Input string\n    int length = 0; // Initialize a counter for the length\n\n    printf(\"Input string: \\\"%s\\\"\\n\", str);\n\n    // Loop through the string until the null terminator ('\\0') is encountered\n    while (str[length] != '\\0') {\n        length++; // Increment the counter for each character\n    }\n\n    printf(\"The length of the string is: %d\\n\", length);\n\n    return 0;\n}\n```\n\n**Explanation:**\n1.  **Initialization**: A `char` array `str` is declared and initialized with the given string. An integer variable `length` is initialized to `0`. This variable will store the calculated length.\n2.  **Looping through the String**: C strings are null-terminated, meaning they end with a special character `\\0`. A `while` loop is used to iterate through the characters of the string. The loop continues as long as the character at the current `length` index is not `\\0`.\n3.  **Incrementing Length**: In each iteration of the loop, `length` is incremented. This effectively counts each character in the string before the null terminator.\n4.  **Output**: Once the `while` loop terminates (i.e., `\\0` is found), the `length` variable holds the total number of characters in the string, which is then printed.",
            "answer_source": "generated",
            "chapter": "Unit 3: String Basics - String Declaration and Initialization - Operations on Strings"
        },
        {
            "question_number": "12b",
            "question_text": "i) Explain how arrays are passed to functions in C. Write a code example demonstrating how to pass an array and modify its elements within the function.\nii) In a library system, a function updates a book's price based on user feedback. The function takes the book title and new price as inputs and updates the price directly without returning anything. Explain why it's better to use call by reference here. Write a C function to update the book's price using call by reference and check the change in the main program.",
            "marks": 10,
            "answer": "**(i) How arrays are passed to functions in C and modification example:**\n\nIn C, arrays are always passed to functions by what is effectively **\"call by reference\"** (or more precisely, the array name decays to a pointer). When you pass an array name to a function, a copy of the **address of the array's first element** (a pointer) is passed, not a copy of the entire array. This means that the function receives a pointer to the original array in memory. Any modifications made to the array elements within the function using this pointer will directly affect the original array in the calling function.\n\nBecause only the base address is passed, the function doesn't inherently know the array's size. Therefore, it's common practice to pass the array's size as a separate argument to the function.\n\n**Code Example Demonstrating Array Modification:**\n\n```c\n#include <stdio.h>\n\n// Function to double each element of an integer array\nvoid doubleArrayElements(int *arr, int size) {\n    printf(\"\\n--- Inside doubleArrayElements function ---\\n\");\n    printf(\"Array before modification (inside function): \");\n    for (int i = 0; i < size; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n\");\n\n    for (int i = 0; i < size; i++) {\n        arr[i] = arr[i] * 2; // Modify the actual element in memory\n    }\n\n    printf(\"Array after modification (inside function): \");\n    for (int i = 0; i < size; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    int numbers[] = {10, 20, 30, 40, 50};\n    int size = sizeof(numbers) / sizeof(numbers[0]); // Calculate array size\n\n    printf(\"--- Main program ---\\n\");\n    printf(\"Original array in main: \");\n    for (int i = 0; i < size; i++) {\n        printf(\"%d \", numbers[i]);\n    }\n    printf(\"\\n\");\n\n    // Call the function, passing the array (its base address) and its size\n    doubleArrayElements(numbers, size);\n\n    printf(\"\\n--- Main program after function call ---\\n\");\n    printf(\"Array in main after function call: \");\n    for (int i = 0; i < size; i++) {\n        printf(\"%d \", numbers[i]);\n    }\n    printf(\"\\n\");\n\n    // Verify the change\n    if (numbers[0] == 20) {\n        printf(\"Verification: Array elements in main were successfully modified.\\n\");\n    } else {\n        printf(\"Verification: Array elements in main were NOT modified.\\n\");\n    }\n\n    return 0;\n}\n```\n**Explanation:** The `doubleArrayElements` function takes `int *arr` (a pointer to the first element) and `int size`. Inside the function, the `for` loop iterates and multiplies each `arr[i]` by 2. Because `arr` points to the *original* `numbers` array in `main`, these changes are directly applied to `numbers`. The output confirms that the `numbers` array in `main` is indeed modified after the function call.\n\n--- \n\n**(ii) Call by Reference for updating book price:**\n\n**Why Call by Reference is better:**\nIn the library system scenario, the requirement is to *update the book's price directly* and for this change to be permanent. If you were to use \"call by value\" for the book's price, the function would receive a *copy* of the price. Any modifications made to this copy within the function would not affect the original price variable in the `main` program. To make a permanent change to a variable in the calling function without explicitly returning a value and reassigning it, \"call by reference\" using **pointers** is the appropriate mechanism. By passing the *address* of the price variable (or the entire book structure), the function can dereference the pointer and modify the value at that memory location, ensuring the change persists outside the function's scope.\n\n**C Function to Update Book Price Using Call by Reference:**\n\n```c\n#include <stdio.h>\n#include <string.h>\n\n// Define a structure for a Book\ntypedef struct {\n    char title[100];\n    float price;\n} Book;\n\n// Function to update a book's price using call by reference\n// It takes a pointer to a Book structure and the new price\nvoid updateBookPrice(Book *bookPtr, float newPrice) {\n    printf(\"\\n--- Inside updateBookPrice function ---\\n\");\n    printf(\"Book '%s' old price: %.2f\\n\", bookPtr->title, bookPtr->price);\n\n    // Modify the price through the pointer\n    bookPtr->price = newPrice;\n\n    printf(\"Book '%s' price updated to: %.2f\\n\", bookPtr->title, bookPtr->price);\n    printf(\"--- Exiting updateBookPrice function ---\\n\");\n}\n\nint main() {\n    Book myBook; // Declare a Book variable\n\n    // Initialize book details\n    strcpy(myBook.title, \"The Great C Novel\");\n    myBook.price = 29.99;\n\n    printf(\"--- Main program ---\\n\");\n    printf(\"Initial book details in main:\\n\");\n    printf(\"Title: %s, Price: %.2f\\n\", myBook.title, myBook.price);\n\n    // Call the function, passing the address of myBook (call by reference)\n    // and the new price\n    updateBookPrice(&myBook, 35.50);\n\n    printf(\"\\n--- Main program after function call ---\\n\");\n    printf(\"Book details in main after update:\\n\");\n    printf(\"Title: %s, Price: %.2f\\n\", myBook.title, myBook.price);\n\n    // Check the change in the main program\n    if (myBook.price == 35.50) {\n        printf(\"Verification: Book price in main was successfully updated to %.2f.\\n\", myBook.price);\n    } else {\n        printf(\"Verification: Book price in main was NOT updated.\\n\");\n    }\n\n    return 0;\n}\n```\n**Explanation:**\n1.  **Book Structure**: A `Book` `struct` is defined to hold the `title` and `price` of a book.\n2.  **`updateBookPrice` Function**: This function takes `Book *bookPtr` (a pointer to a `Book` structure) and `newPrice` as arguments. Inside the function, `bookPtr->price = newPrice;` uses the dereferencing operator (`->`) to access the `price` member of the `Book` structure that `bookPtr` points to, and updates its value. Since `bookPtr` holds the *actual memory address* of `myBook` from `main`, this change is made directly to `myBook`.\n3.  **`main` Function**: In `main`, a `Book` variable `myBook` is declared and initialized. When `updateBookPrice(&myBook, 35.50);` is called, the **address** of `myBook` (`&myBook`) is passed. The output clearly shows that after the function call, `myBook.price` in `main` reflects the new value (35.50), demonstrating that the call by reference successfully updated the original variable.",
            "answer_source": "generated",
            "chapter": "Unit 3: String Basics - Call by Value, Call by Reference"
        },
        {
            "question_number": "13a",
            "question_text": "i) Write a Python program that accepts a string and counts the number of vowels (a, e, i, o, u) in the string. Do not use any external libraries.\nii) Explain how tuples differ from lists in Python. Write a Python program that creates a tuple and attempts to modify one of its elements, then demonstrate the result.",
            "marks": 10,
            "answer": "**(i) Python program to count vowels:**\n\n```python\ndef count_vowels(input_string):\n    vowels = \"aeiouAEIOU\"  # Define all possible vowels (both cases)\n    vowel_count = 0\n    for char in input_string:  # Iterate through each character in the input string\n        if char in vowels:      # Check if the current character is a vowel\n            vowel_count += 1    # Increment the counter if it is\n    return vowel_count\n\n# Get input from the user\ntext = input(\"Enter a string: \")\n\n# Call the function and print the result\ncount = count_vowels(text)\nprint(f\"The number of vowels in the string is: {count}\")\n```\n\n**Explanation:**\n1.  **`count_vowels` Function**: This function takes one argument, `input_string`. It defines a string `vowels` containing all lowercase and uppercase vowels to simplify the checking process.\n2.  **Iteration and Check**: It then uses a `for` loop to iterate over each `char` in the `input_string`. Inside the loop, it checks if `char` is present in the `vowels` string using the `in` operator. If a character is a vowel, `vowel_count` is incremented.\n3.  **Return Value**: After checking all characters, the function returns the final `vowel_count`.\n4.  **User Interaction**: In the main part of the script, `input()` is used to get a string from the user, which is then passed to `count_vowels`, and the result is printed.\n\n--- \n\n**(ii) Explanation of differences between Tuples and Lists, with immutability demonstration:**\n\n**Differences between Tuples and Lists in Python:**\n1.  **Mutability**: This is the most significant difference.\n    *   **Lists** are **mutable**: Their elements can be changed (added, removed, or modified) after the list is created. They are defined using square brackets `[]`.\n    *   **Tuples** are **immutable**: Once a tuple is created, its elements cannot be changed, added, or removed. They are defined using parentheses `()`.\n2.  **Syntax**: Lists use square brackets `[]`, while tuples use parentheses `()`.\n3.  **Performance**: Tuples are generally faster than lists when iterating over their elements, especially for large collections, because their size and contents are fixed, allowing for certain optimizations.\n4.  **Use Cases**: Lists are suitable for collections of items that might change during the program's execution (e.g., a dynamic list of items in a shopping cart). Tuples are suitable for collections of items that should remain constant (e.g., coordinates, database records, fixed configurations). Tuples can also be used as dictionary keys (because they are hashable due to immutability), whereas lists cannot.\n5.  **Memory Usage**: For similar data, tuples can sometimes consume less memory than lists because they don't need to allocate extra space for potential growth/modification.\n\n**Python program demonstrating tuple immutability:**\n\n```python\n# Create a list\nmy_list = [10, 20, 30]\nprint(f\"Original list: {my_list}\")\n\n# Demonstrate modifying an element in a list (this is possible)\nmy_list[1] = 25\nprint(f\"List after modifying element at index 1: {my_list}\")\n\n# Create a tuple\nmy_tuple = (100, 200, 300)\nprint(f\"\\nOriginal tuple: {my_tuple}\")\n\n# Attempt to modify an element in the tuple (this will cause an error)\nprint(\"Attempting to modify an element in the tuple...\")\ntry:\n    my_tuple[1] = 250 # This line will raise a TypeError\n    print(f\"Tuple after attempting to modify element: {my_tuple}\")\nexcept TypeError as e:\n    print(f\"Error caught: {e}\")\n    print(\"This demonstrates that tuples are immutable; their elements cannot be changed after creation.\")\n```\n\n**Explanation:**\nThe program first shows that an element in `my_list` (a list) can be successfully modified. Then, it attempts to modify an element in `my_tuple` (a tuple) at index 1. As expected, this operation raises a `TypeError` with a message similar to `'tuple' object does not support item assignment`. This error clearly illustrates the fundamental difference: lists are mutable (changeable), while tuples are immutable (unchangeable) after creation. The `try-except` block is used to gracefully handle this expected error.",
            "answer_source": "generated",
            "chapter": "Unit 4: Python: Working with List structures - Working with Tuples data structures"
        },
        {
            "question_number": "13b",
            "question_text": "Write a Python program that takes a dictionary of students with their names and marks as input. The program should:\nFind the student with the highest marks.\nDisplay the student's name and marks.\n(Use Python's dictionary methods and max() function.)",
            "marks": 10,
            "answer": "```python\ndef find_highest_scorer(student_marks):\n    if not student_marks: # Handle case of an empty dictionary\n        return \"No student data provided to analyze.\"\n\n    # Use max() function with a custom key to find the item (key-value pair) \n    # that has the maximum value (marks).\n    # student_marks.items() returns a view of (key, value) pairs as tuples.\n    # The lambda function `lambda item: item[1]` tells max() to compare based on the 2nd element \n    # of each (name, marks) tuple, which is the marks.\n    highest_scorer_name, highest_marks = max(student_marks.items(), key=lambda item: item[1])\n\n    return f\"The student with the highest marks is: {highest_scorer_name} with {highest_marks} marks.\"\n\n# Example input: A dictionary of students with names and marks\nstudents_data = {\n    \"Alice\": 88,\n    \"Bob\": 92,\n    \"Charlie\": 75,\n    \"David\": 95,\n    \"Eve\": 81,\n    \"Frank\": 92.5 # Example with float marks\n}\n\nprint(\"Student Marks Data:\")\nfor name, marks in students_data.items():\n    print(f\"  {name}: {marks}\")\n\n# Call the function to find and display the highest scorer\nresult = find_highest_scorer(students_data)\nprint(f\"\\n{result}\")\n\n# Test with an empty dictionary\nempty_students_data = {}\nempty_result = find_highest_scorer(empty_students_data)\nprint(f\"\\nEmpty data test: {empty_result}\")\n```\n\n**Explanation:**\n1.  **`find_highest_scorer` Function**: This function takes a dictionary `student_marks` as input.\n2.  **Handle Empty Input**: It first checks if the `student_marks` dictionary is empty. If it is, a corresponding message is returned to prevent errors.\n3.  **Using `max()` with `key`**: The core logic is `max(student_marks.items(), key=lambda item: item[1])`.\n    *   `student_marks.items()`: This dictionary method returns a view of key-value pairs as a list of `(key, value)` tuples (e.g., `('Alice', 88)`).\n    *   `max()`: The built-in `max()` function finds the largest item in an iterable.\n    *   `key=lambda item: item[1]`: This is a crucial part. `key` is an optional argument that specifies a single-argument function to extract a comparison key from each element in the iterable. The `lambda` function here takes an `item` (which will be a `(name, marks)` tuple) and returns `item[1]` (the marks). So, `max()` will compare the items based on their marks.\n4.  **Unpacking Result**: The `max()` function returns the entire `(name, marks)` tuple corresponding to the highest marks. This tuple is then unpacked into `highest_scorer_name` and `highest_marks`.\n5.  **Output**: Finally, the function returns a formatted string displaying the name and marks of the student with the highest score. The example demonstrates the function with a sample `students_data` dictionary and also includes a test case for an empty dictionary.",
            "answer_source": "generated",
            "chapter": "Unit 4: Python: Working with Dictionaries"
        },
        {
            "question_number": "14a",
            "question_text": "i) You are a data analyst at a company. Your manager has asked you to look at the salary information for the employees. You have a list of employee names and their salaries. Write a Python program that creates a table (DataFrame) with employee names and their salaries.\nii) Following the previous question, your manager now asks you to increase each employee's salary by 10%. Write a Python program to modify the table and display the updated salaries.\nData with 10% Salary Increase:\\n\", df)",
            "marks": 10,
            "answer": "**(i) Python program to create a Pandas DataFrame for employee salaries:**\n\n```python\nimport pandas as pd\n\n# Employee data (lists of names and salaries)\nemployee_names = [\"Alice\", \"Bob\", \"Charlie\", \"David\", \"Eve\"]\nemployee_salaries = [50000, 60000, 75000, 55000, 62000]\n\n# Create a dictionary from the lists, where keys will be column names\nemployee_data = {\n    \"Employee Name\": employee_names,\n    \"Salary\": employee_salaries\n}\n\n# Create the Pandas DataFrame\ndf = pd.DataFrame(employee_data)\n\nprint(\"Original Employee Salary DataFrame:\")\nprint(df)\n```\n\n**Explanation:**\n1.  **Import Pandas**: The program begins by importing the `pandas` library, which is essential for working with DataFrames.\n2.  **Prepare Data**: Two Python lists, `employee_names` and `employee_salaries`, are created to hold the respective data.\n3.  **Create Dictionary**: A dictionary `employee_data` is constructed. The keys of this dictionary (`\"Employee Name\"`, `\"Salary\"`) will become the column headers in the DataFrame, and their corresponding values are the lists of data.\n4.  **Create DataFrame**: `pd.DataFrame(employee_data)` is used to convert this dictionary into a Pandas DataFrame (`df`). Pandas automatically assigns a default integer index.\n5.  **Display DataFrame**: The original DataFrame is then printed, showing the employee names and their initial salaries in a tabular format.\n\n--- \n\n**(ii) Python program to increase employee salaries by 10% and display updated DataFrame:**\n\n```python\nimport pandas as pd\n\n# Employee data (re-using the data from part i)\nemployee_names = [\"Alice\", \"Bob\", \"Charlie\", \"David\", \"Eve\"]\nemployee_salaries = [50000, 60000, 75000, 55000, 62000]\n\n# Create the DataFrame (as in part i)\nemployee_data = {\n    \"Employee Name\": employee_names,\n    \"Salary\": employee_salaries\n}\ndf = pd.DataFrame(employee_data)\n\nprint(\"Original Employee Salary DataFrame:\")\nprint(df)\n\n# Increase each employee's salary by 10%\n# Pandas allows direct vectorized operations on columns.\n# df[\"Salary\"] refers to the entire 'Salary' column.\n# Multiplying it by 1.10 applies the operation to every element in the column.\ndf[\"Salary\"] = df[\"Salary\"] * 1.10\n\nprint(\"\\nData with 10% Salary Increase:\")\nprint(df)\n```\n\n**Explanation:**\n1.  **Initial DataFrame**: This part of the program starts by creating the same `df` DataFrame as in part (i).\n2.  **Salary Increase**: The key operation is `df[\"Salary\"] = df[\"Salary\"] * 1.10`. Pandas DataFrames allow for vectorized operations, meaning arithmetic operations applied to a Series (a column in a DataFrame) are automatically applied element-wise to every value in that Series. Here, each salary in the 'Salary' column is multiplied by 1.10 (representing a 10% increase), and the updated values are assigned back to the 'Salary' column.\n3.  **Display Updated DataFrame**: Finally, the modified `df` DataFrame is printed, which now shows all employees with their salaries increased by 10%.",
            "answer_source": "generated",
            "chapter": "Unit 5: Introduction to Pandas - Creating Series Objects, Data Frame Objects - Simple Operations with Data frames - Applying Functions to Data frames"
        },
        {
            "question_number": "14b",
            "question_text": "Perform the following tasks using NumPy:\ni). Write a NumPy program to create an array containing all even numbers from 120 to 170.\nii). Create a NumPy array with 10 elements and update the element at index 5 to 1000.\niii). Define a NumPy array al with values ['apple', 'mango', 'banana', 'mango']. Then, create a Boolean array b that checks if each element in al is 'mango'. Finally, use b to retrieve the elements from al that are 'mango'.",
            "marks": 10,
            "answer": "```python\nimport numpy as np\n\n# i) Create a NumPy array containing all even numbers from 120 to 170.\nprint(\"--- Task i: Even numbers from 120 to 170 ---\")\n# np.arange(start, stop, step) generates values in the interval [start, stop), with a step size.\n# To include 170, the stop value must be 171 (or any number > 170).\neven_numbers_array = np.arange(120, 171, 2)\nprint(\"NumPy array of even numbers (120-170):\")\nprint(even_numbers_array)\nprint(\"\\n\")\n\n# ii) Create a NumPy array with 10 elements and update the element at index 5 to 1000.\nprint(\"--- Task ii: Create and update array element ---\")\n# Create an array of 10 elements. We can start with zeros or any other values.\nmy_array = np.zeros(10, dtype=int) # Creates [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\nprint(\"Original NumPy array (10 elements):\")\nprint(my_array)\n\n# Update the element at index 5 to 1000\n# NumPy arrays are 0-indexed, so index 5 is the 6th element.\nmy_array[5] = 1000\nprint(\"NumPy array after updating element at index 5 to 1000:\")\nprint(my_array)\nprint(\"\\n\")\n\n# iii) Define a NumPy array 'al' with values ['apple', 'mango', 'banana', 'mango'].\n# Then, create a Boolean array 'b' that checks if each element in 'al' is 'mango'.\n# Finally, use 'b' to retrieve the elements from 'al' that are 'mango'.\nprint(\"--- Task iii: Boolean indexing and retrieval ---\")\n# Define the NumPy array 'al' with string values\nal = np.array(['apple', 'mango', 'banana', 'mango'])\nprint(\"Array 'al':\")\nprint(al)\n\n# Create a Boolean array 'b' by comparing each element of 'al' to 'mango'\nb = (al == 'mango')\nprint(\"Boolean array 'b' (where al == 'mango'):\")\nprint(b)\n\n# Use the Boolean array 'b' to retrieve elements from 'al' that are 'mango'\n# This is known as Boolean indexing or filtering.\nmango_elements = al[b]\nprint(\"Elements from 'al' that are 'mango' (using Boolean indexing):\")\nprint(mango_elements)\nprint(\"\\n\")\n```\n\n**Explanation:**\n*   **Task i (Even numbers array)**: `np.arange(start, stop, step)` is used to generate a sequence of numbers. `120` is the starting number. `171` is used as the stop value because `arange` generates numbers up to, but not including, the stop value. `2` is the step size, ensuring only even numbers are included.\n*   **Task ii (Array creation and update)**: `np.zeros(10, dtype=int)` creates a 1D NumPy array of 10 integer elements, all initialized to 0. Direct indexing `my_array[5] = 1000` is then used to change the value of the element at the 6th position (index 5) in the array.\n*   **Task iii (Boolean indexing)**: First, `al = np.array(['apple', 'mango', 'banana', 'mango'])` creates an array of strings. Then, `b = (al == 'mango')` performs an element-wise comparison, resulting in a boolean array `b` (`[False, True, False, True]`). Finally, `al[b]` uses this boolean array as a mask to select and retrieve only those elements from `al` where the corresponding value in `b` is `True`, effectively filtering for 'mango'.",
            "answer_source": "generated",
            "chapter": "Unit 5: Creating NumPy Array - Numpy Indexing - Slicing using Numpy"
        }
    ]
}