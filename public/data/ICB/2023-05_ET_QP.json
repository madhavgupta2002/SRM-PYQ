{
  "paper_title": "B.Tech. DEGREE EXAMINATION, MAY 2023 Fifth Semester 18GEO104T-COMPUTATIONAL GENOMICS",
  "source": "2023-05 ET",
  "questions": [
    {
      "question_number": "1",
      "question_text": "Which of the following is not present in DNA?\n(A) Adenine\n(B) Guanine\n(C) Cytosine\n(D) Uracil",
      "marks": 1,
      "answer": "Uracil is a nitrogenous base found in RNA, replacing thymine which is found in DNA. DNA contains Adenine, Guanine, Cytosine, and Thymine.",
      "answer_source": "generated",
      "chapter": "Unit 2: Basics in Biochemistry"
    },
    {
      "question_number": "2",
      "question_text": "Which of the following is not a part of central dogma of molecular biology?\n(A) RNA\n(B) Protein\n(C) Virus\n(D) DNA",
      "marks": 1,
      "answer": "The central dogma of molecular biology describes the flow of genetic information from DNA to RNA to Protein. Viruses are biological entities but are not a fundamental component of the central dogma itself, although they interact with host cellular machinery that follows the dogma.",
      "answer_source": "generated",
      "chapter": "Unit 2: Basics in Biochemistry"
    },
    {
      "question_number": "3",
      "question_text": "Study of total gene expression of a cell is called as\n(A) Lipidomics\n(B) Proteomics\n(C) Transcriptomics\n(D) Genomics",
      "marks": 1,
      "answer": "Transcriptomics is the study of the complete set of RNA transcripts produced by an organism or in a specific cell type under specific conditions, reflecting total gene expression. Genomics is the study of the entire genome, Proteomics is the study of the entire set of proteins, and Lipidomics is the study of lipids.",
      "answer_source": "generated",
      "chapter": "Unit 2: Basics in Biochemistry"
    },
    {
      "question_number": "4",
      "question_text": "Which of the following is a stop codon?\n(A) AUG\n(B) UAG\n(C) CGG\n(D) GGC",
      "marks": 1,
      "answer": "UAG is one of the three standard stop codons (UAA, UAG, UGA) that signal the termination of protein synthesis. AUG is the start codon.",
      "answer_source": "generated",
      "chapter": "Unit 3: Structure Biology"
    },
    {
      "question_number": "5",
      "question_text": "Which of the following is not a nucleotide sequence database?\n(A) Genbank\n(B) EMBL\n(C) DDBJ\n(D) Uniprot",
      "marks": 1,
      "answer": "Uniprot is a comprehensive, high-quality, and freely accessible database of protein sequences and functional information. GenBank, EMBL (European Molecular Biology Laboratory), and DDBJ (DNA Data Bank of Japan) are major nucleotide sequence databases.",
      "answer_source": "generated",
      "chapter": "Unit 2: Basics in Biochemistry"
    },
    {
      "question_number": "6",
      "question_text": "Which of the following is not a sequence file format related to genomic data?\n(A) PDB\n(B) BAM\n(C) Fastq\n(D) Genbank",
      "marks": 1,
      "answer": "PDB (Protein Data Bank) format is used for representing the 3D atomic coordinates of proteins and nucleic acids, not for genomic sequence data itself. FASTQ, BAM, and GenBank are common formats for storing nucleotide sequence data and related genomic information.",
      "answer_source": "generated",
      "chapter": "Unit 3: Structure Biology"
    },
    {
      "question_number": "7",
      "question_text": "Which of the following is not a part of level Gene Ontology studies?\n(A) Biological Process\n(B) Cellular Component\n(C) Molecular Function\n(D) Enzyme Action",
      "marks": 1,
      "answer": "Gene Ontology (GO) is a hierarchical classification system for describing gene and protein functions. It has three main categories: Biological Process, Molecular Function, and Cellular Component. 'Enzyme Action' is a specific type of Molecular Function, not a separate top-level category.",
      "answer_source": "generated",
      "chapter": "Unit 2: Basics in Biochemistry"
    },
    {
      "question_number": "8",
      "question_text": "Which of the following is not related to homology?\n(A) Orthology\n(B) Paralogy\n(C) Xenology\n(D) Parasitology",
      "marks": 1,
      "answer": "Parasitology is the study of parasites and their relationships with their hosts. Orthology, Paralogy, and Xenology are different types of homologous relationships between genes or proteins, describing their evolutionary origins (e.g., speciation, duplication, horizontal transfer).",
      "answer_source": "generated",
      "chapter": "Unit 1: Cell and Evolution"
    },
    {
      "question_number": "9",
      "question_text": "The data stored in the R data frame cannot be a ___ type.\n(A) numeric\n(B) factor\n(C) character\n(D) special function",
      "marks": 1,
      "answer": "R data frames can store various data types in their columns, including numeric, character, and factor. 'Special function' is not a fundamental data type in R in the same way as numeric, character, or factor.",
      "answer_source": "generated",
      "chapter": "Unit 4: Neurobiology"
    },
    {
      "question_number": "10",
      "question_text": "Which of the following is not a built-in datatype in python under the numeric category?\n(A) int\n(C) complex\n(B) float\n(D) bytes",
      "marks": 1,
      "answer": "In Python, `int` (integers), `float` (floating-point numbers), and `complex` (complex numbers) are numeric data types. `bytes` is a sequence type representing immutable sequences of single bytes.",
      "answer_source": "generated",
      "chapter": "Unit 4: Neurobiology"
    },
    {
      "question_number": "11",
      "question_text": "Which of the following is used in python to concatenate two elements?\n(A) concat ()\n(C) hash\n(B) paste ()\n(D) addition",
      "marks": 1,
      "answer": "In Python, the `+` operator (addition) is used for concatenating sequences like strings and lists. `concat()` and `paste()` are functions often found in other languages or libraries (e.g., R, pandas for `concat`).",
      "answer_source": "generated",
      "chapter": "Unit 4: Neurobiology"
    },
    {
      "question_number": "12",
      "question_text": "Dataframes can be converted into a matrix by calling the following function data\n(A) matr()\n(C) matrixf()\n(B) matrix()\n(D) matrixfunc()",
      "marks": 1,
      "answer": "In R, a data frame can be converted to a matrix using the `as.matrix()` function. Among the given options, `matrix()` is the closest, though `as.matrix()` is the direct conversion function. `matrix()` itself constructs a matrix from elements.",
      "answer_source": "generated",
      "chapter": "Unit 4: Neurobiology"
    },
    {
      "question_number": "13",
      "question_text": "The content of a package is only available when a package is loaded using\n(A) install()\n(C) update()\n(B) library()\n(D) search()",
      "marks": 1,
      "answer": "In R, `library()` is used to load an installed package into the current R session, making its functions and data available for use. `install.packages()` is for installing, and `update.packages()` is for updating.",
      "answer_source": "generated",
      "chapter": "Unit 4: Neurobiology"
    },
    {
      "question_number": "14",
      "question_text": "Differential gene expression analysis can NOT be done using\n(A) RSEM\n(C) DESeq\n(B) edgeR\n(D) limma",
      "marks": 1,
      "answer": "DESeq, edgeR, and limma are popular R/Bioconductor packages specifically designed and widely used for performing differential gene expression analysis on RNA-seq data. RSEM (RNA-Seq Expectation-Maximization) is a software package for quantifying gene and isoform expression levels from RNA-seq data, which is a precursor step to differential expression analysis, but RSEM itself does not perform the differential analysis.",
      "answer_source": "generated",
      "chapter": "Unit 2: Basics in Biochemistry"
    },
    {
      "question_number": "15",
      "question_text": "______ are built in R so that you get HTML.\n(A) Vignettes\n(C) Bignats\n(B) Vighnaants\n(D) Viddnets",
      "marks": 1,
      "answer": "Vignettes are introductory documents, tutorials, or guides for R packages. They are typically written in R Markdown or Sweave and can be rendered into various formats, including HTML, to provide rich documentation.",
      "answer_source": "generated",
      "chapter": "Unit 4: Neurobiology"
    },
    {
      "question_number": "16",
      "question_text": "______ consists of commands to create complex plots from data in a data frame.\n(A) ggplot2\n(C) clusterProfiler\n(B) ABSSeq\n(D) splots",
      "marks": 1,
      "answer": "ggplot2 is a powerful and widely used R package for creating elegant and complex data visualizations based on the Grammar of Graphics. It allows users to build plots layer by layer, offering extensive control over aesthetics and data mapping.",
      "answer_source": "generated",
      "chapter": "Unit 4: Neurobiology"
    },
    {
      "question_number": "17",
      "question_text": "How many open reading frames are there?",
      "marks": 1,
      "answer": "There are six possible open reading frames (ORFs) in a double-stranded DNA molecule: three in the forward direction (starting from each of the three possible reading frames) and three in the reverse direction on the complementary strand.",
      "answer_source": "generated",
      "chapter": "Unit 3: Structure Biology"
    },
    {
      "question_number": "18",
      "question_text": "Bio.Alphabet.IUPAC provides definitions for DNA, RNA and proteins, but ______ module.\n(A) IUPACProtein\n(B) IUPACUnambiguousDNA\n(C) IUPACUnambiguousRNA\n(D) IUPACDNA",
      "marks": 1,
      "answer": "The `Bio.Alphabet.IUPAC` module in Biopython provides definitions for various IUPAC alphabets, including specific ones like `IUPACProtein`, `IUPACUnambiguousDNA`, `IUPACUnambiguousRNA`, and `IUPACDNA` (which typically refers to unambiguous DNA). All options are indeed provided by this module. The question is slightly ambiguous, but if it's asking for a correct example, `IUPACUnambiguousDNA` is a common and distinct type.",
      "answer_source": "generated",
      "chapter": "Unit 4: Neurobiology"
    },
    {
      "question_number": "19",
      "question_text": "The Seq object is\n(A) writable\n(B) readable\n(C) executable\n(D) revokable",
      "marks": 1,
      "answer": "In Biopython, a `Seq` object represents an immutable biological sequence. This means its content cannot be changed after creation; it is essentially 'readable' or read-only.",
      "answer_source": "generated",
      "chapter": "Unit 4: Neurobiology"
    },
    {
      "question_number": "20",
      "question_text": "The SeqRecord (Sequence Record) class is defined in the ______ module.\n(A) Bio.SeqRecord\n(C) BioSeqRecord\n(B) Bio_SeqRecord\n(D) SeqRecord",
      "marks": 1,
      "answer": "The `SeqRecord` class, which combines a `Seq` object with additional annotation like an ID, name, description, and features, is defined in the `Bio.SeqRecord` module of Biopython.",
      "answer_source": "generated",
      "chapter": "Unit 4: Neurobiology"
    },
    {
      "question_number": "21",
      "question_text": "Compare Intron and Exon.",
      "marks": 4,
      "answer": "Introns are non-coding segments within a eukaryotic gene that are transcribed into pre-mRNA but are subsequently removed by RNA splicing before the mRNA is translated into protein. Exons, on the other hand, are the coding segments of a eukaryotic gene that remain in the mature mRNA and are eventually translated into protein. Introns typically start with GT and end with AG splice sites. Exons contain the actual genetic information that dictates the amino acid sequence of a protein.",
      "answer_source": "generated",
      "chapter": "Unit 3: Structure Biology"
    },
    {
      "question_number": "22",
      "question_text": "Comment about different types of RNA.",
      "marks": 4,
      "answer": "RNA (Ribonucleic Acid) exists in several forms, each with distinct functions crucial for gene expression and regulation:\n1.  **mRNA (messenger RNA):** Carries the genetic code from DNA in the nucleus to ribosomes in the cytoplasm, where it serves as a template for protein synthesis.\n2.  **tRNA (transfer RNA):** Functions as an adaptor molecule in protein synthesis, carrying specific amino acids to the ribosome based on the codons in the mRNA.\n3.  **rRNA (ribosomal RNA):** A major component of ribosomes, where it plays both structural and catalytic roles in protein synthesis.\n4.  **snRNA (small nuclear RNA):** Involved in splicing, the process of removing introns from pre-mRNA.\n5.  **miRNA (micro RNA):** Small non-coding RNAs that regulate gene expression by binding to mRNA molecules and inhibiting translation or promoting mRNA degradation.\n6.  **siRNA (small interfering RNA):** Similar to miRNA, these small RNAs are involved in RNA interference, typically by targeting specific mRNA for degradation.\n7.  **lncRNA (long non-coding RNA):** A diverse class of RNA molecules longer than 200 nucleotides that do not code for proteins but play various roles in gene regulation, chromatin modification, and cellular processes.",
      "answer_source": "generated",
      "chapter": "Unit 2: Basics in Biochemistry"
    },
    {
      "question_number": "23",
      "question_text": "Summarize the important features of FastQ file format.",
      "marks": 4,
      "answer": "The FASTQ file format is a text-based format used to store both a nucleotide sequence and its corresponding quality scores. It is widely used in high-throughput sequencing data, especially for raw reads from next-generation sequencing platforms. Each sequence entry in a FASTQ file typically consists of four lines:\n1.  **Line 1 (Sequence Identifier):** Starts with an '@' character, followed by a sequence identifier and optional descriptive text, similar to a FASTA header.\n2.  **Line 2 (Raw Sequence):** Contains the actual nucleotide sequence (e.g., A, T, C, G, N).\n3.  **Line 3 (Separator):** Starts with a '+' character and may optionally repeat the sequence identifier and description, or simply be a '+'.\n4.  **Line 4 (Quality Scores):** Contains a string of ASCII characters, where each character represents the Phred quality score for the corresponding base in Line 2. The ASCII value of the character encodes the quality score, indicating the probability of an incorrect base call.",
      "answer_source": "generated",
      "chapter": "Unit 2: Basics in Biochemistry"
    },
    {
      "question_number": "24",
      "question_text": "Write short notes on vectors in R.",
      "marks": 4,
      "answer": "In R, vectors are the most basic and fundamental data structures. They are one-dimensional arrays used to store an ordered collection of elements of the *same* data type. This homogeneity is a key characteristic; a vector can contain numbers, characters, logical values (TRUE/FALSE), or factors, but not a mix of these types (if mixed, R will coerce all elements to the most general type, typically character). Vectors are created using the `c()` function (combine). For example, `numeric_vector <- c(1, 2, 3)` creates a numeric vector, and `char_vector <- c(\"apple\", \"banana\")` creates a character vector. Individual elements can be accessed using square brackets and their index (e.g., `numeric_vector[1]`).",
      "answer_source": "generated",
      "chapter": "Unit 4: Neurobiology"
    },
    {
      "question_number": "25",
      "question_text": "Write the importance of classes and objects in Python.",
      "marks": 4,
      "answer": "Classes and objects are foundational concepts in Object-Oriented Programming (OOP) in Python, offering several significant advantages:\n1.  **Modularity and Reusability:** Classes act as blueprints for creating objects, allowing developers to define common attributes and methods once and reuse them across multiple objects, promoting modular and reusable code.\n2.  **Encapsulation:** Objects encapsulate data (attributes) and the functions (methods) that operate on that data into a single unit. This hides internal implementation details from the outside world, making code more organized and less prone to errors.\n3.  **Data Abstraction:** Classes allow for the creation of abstract data types, focusing on what an object does rather than how it does it. Users interact with objects through well-defined interfaces without needing to know the complex internal workings.\n4.  **Code Organization:** OOP helps structure large programs into manageable, self-contained units, making code easier to understand, maintain, and debug.\n5.  **Polymorphism and Inheritance:** These OOP principles (though not directly asked) further enhance reusability and flexibility, allowing objects of different classes to be treated as objects of a common type, and enabling new classes to inherit properties from existing ones.",
      "answer_source": "generated",
      "chapter": "Unit 4: Neurobiology"
    },
    {
      "question_number": "26",
      "question_text": "Define GViz package.",
      "marks": 4,
      "answer": "The GViz (Genomic Visualization) package is an R/Bioconductor package that provides a highly flexible and extensible framework for visualizing genomic data. It enables the creation of 'track-based' plots, which are commonly used in genomics to display various types of genomic information (e.g., gene annotations, sequence alignments, genomic variations, ChIP-seq peaks) as layers or 'tracks' along a genomic coordinate axis. GViz leverages Bioconductor's data structures like `GRanges` and `GAlignments` to seamlessly integrate and display complex genomic features, making it a powerful tool for exploring and interpreting high-throughput sequencing data.",
      "answer_source": "generated",
      "chapter": "Unit 2: Basics in Biochemistry"
    },
    {
      "question_number": "27",
      "question_text": "Define FastA file format.",
      "marks": 4,
      "answer": "The FASTA file format is a text-based format for representing nucleotide or amino acid sequences. It is widely used in bioinformatics for storing and exchanging sequence data. Each sequence in a FASTA file begins with a single-line description, or header, which starts with a greater-than symbol ('>'). The remainder of the line contains an identifier and optional descriptive information. Subsequent lines contain the actual sequence data. The sequence itself can be broken into multiple lines, and white space within the sequence (other than newlines) is typically ignored. This simple yet effective format makes it highly versatile for various bioinformatics tools and applications.",
      "answer_source": "generated",
      "chapter": "Unit 2: Basics in Biochemistry"
    },
    {
      "question_number": "28a",
      "question_text": "Write in detail about the structure and components of a gene with a neat sketch.",
      "marks": 12,
      "answer": "A gene is a fundamental unit of heredity, a segment of DNA that codes for a specific functional product, such as a protein or an RNA molecule. While the exact structure can vary, typical eukaryotic genes comprise several key components:\n\n1.  **Promoter:** This is a regulatory DNA sequence located upstream (5' end) of the transcription start site. It acts as a binding site for RNA polymerase and various transcription factors, initiating the process of gene transcription. Key elements like the TATA box are often found here.\n2.  **Transcription Start Site (TSS):** The precise nucleotide where RNA synthesis begins.\n3.  **5' Untranslated Region (5' UTR):** The segment of mRNA between the transcription start site and the translation start codon (AUG). It is transcribed but not translated into protein and plays roles in mRNA stability and translation regulation.\n4.  **Exons:** These are the coding regions of a gene that are retained in the mature mRNA and translated into protein. They carry the actual genetic information.\n5.  **Introns:** These are non-coding intervening sequences located within a gene that are transcribed into pre-mRNA but are removed during the RNA splicing process. Introns do not contribute to the final protein sequence.\n6.  **Translation Start Codon (AUG):** The specific three-nucleotide sequence that signals the beginning of protein synthesis.\n7.  **Translation Stop Codon (UAA, UAG, UGA):** These three-nucleotide sequences signal the termination of protein synthesis.\n8.  **3' Untranslated Region (3' UTR):** The segment of mRNA located between the translation stop codon and the transcription termination site. It is transcribed but not translated and is involved in mRNA stability, localization, and translation efficiency.\n9.  **Terminator (Transcription Termination Signal):** A sequence located downstream of the 3' UTR that signals the RNA polymerase to stop transcription and detach from the DNA template.\n10. **Enhancers and Silencers:** These are regulatory DNA sequences that can be located far from the gene (upstream, downstream, or even within introns) and influence the rate of transcription. Enhancers increase gene expression, while silencers decrease it.\n\n**Sketch (Conceptual):**\n\nEnhancer/Silencer   Promoter   TSS   5'UTR   Exon 1   Intron 1   Exon 2   Intron 2   Exon 3   3'UTR   Terminator\n<--------------------|-----------------|-----------|--------------|----------------|----------------|--------------|----------------|------------|-----------|----------->\n                   |   RNA Polymerase Binding  |                |                |                |                |                |            |           |\n                                       |   Start     |                |                |                |                |            |   Stop    |\n                                       |   Codon     |                |                |                |                |            |   Codon   |\n                                       +-------------+                +----------------+                +----------------+            +-----------+\n                                   <---------------------------------- Pre-mRNA ----------------------------------------------------->\n                                                                        (after transcription)\n\n                                                     <---------------------------------- Mature mRNA ----------------------------------------------------->\n                                                                            (after splicing, introns removed)\n\n                                                                               <---------------------------------- Protein ----------------------------------------------------->\n                                                                                        (after translation)\n",
      "answer_source": "generated",
      "chapter": "Unit 3: Structure Biology"
    },
    {
      "question_number": "28b",
      "question_text": "Explain in detail the significance and scope of bioinformatics in biological research.",
      "marks": 12,
      "answer": "Bioinformatics is an interdisciplinary field that combines biology, computer science, mathematics, and statistics to analyze and interpret large biological datasets. Its significance and scope in modern biological research are immense, particularly with the advent of high-throughput technologies.\n\n**Significance of Bioinformatics:**\n1.  **Handling Big Data:** High-throughput techniques (e.g., next-generation sequencing, mass spectrometry) generate enormous volumes of biological data. Bioinformatics provides the computational tools and algorithms necessary to store, organize, process, and analyze this data efficiently.\n2.  **Accelerating Discovery:** It enables researchers to identify novel genes, proteins, and regulatory elements; discover disease biomarkers; and understand complex biological pathways, thereby speeding up drug discovery, vaccine development, and agricultural improvements.\n3.  **Personalized Medicine:** By analyzing individual genomic, proteomic, and transcriptomic data, bioinformatics helps tailor medical treatments to a patient's unique genetic makeup, leading to more effective and safer therapies.\n4.  **Understanding Evolution:** Comparative genomics, a major application of bioinformatics, allows for the study of evolutionary relationships between species, identifying conserved genes and understanding how genomes evolve.\n5.  **Predictive Biology:** It moves beyond descriptive biology to predictive models, such as predicting protein structures, gene functions, drug interactions, and disease susceptibility, guiding experimental design.\n\n**Scope of Bioinformatics:**\n1.  **Genomics:** This includes whole-genome sequencing and assembly, gene annotation, identifying genetic variations (SNPs, indels), comparative genomics across species, and population genetics studies.\n2.  **Transcriptomics:** Analyzing gene expression patterns using RNA-Seq, microarrays, and other technologies to understand gene regulation, identify disease states, and study developmental processes.\n3.  **Proteomics:** Involves identifying and quantifying proteins, predicting protein structures (e.g., using AlphaFold), analyzing protein-protein interactions, and understanding post-translational modifications. Structural bioinformatics plays a crucial role here.\n4.  **Systems Biology:** Integrating diverse biological data (genomic, proteomic, metabolomic) to build comprehensive models of biological systems and networks, understanding how components interact to produce cellular functions.\n5.  **Drug Discovery and Development:** Rational drug design, virtual screening of chemical libraries, lead optimization, and predicting drug targets and off-target effects rely heavily on bioinformatics tools and databases.\n6.  **Immunoinformatics:** Applying computational methods to understand immune system components, predict epitopes for vaccine design, and analyze immune responses.\n7.  **Neurobiology:** Analyzing complex neurological data, building models of neural networks, and applying machine learning to understand brain function and disease.\n8.  **Data Mining and Machine Learning in Biology:** Utilizing advanced computational algorithms for pattern recognition, classification, and prediction from biological datasets, such as identifying disease subtypes or predicting protein functions.\n\nIn essence, bioinformatics has transformed biology from a largely experimental science to a data-driven discipline, providing the tools and insights needed to navigate the complexity of living systems.",
      "answer_source": "generated",
      "chapter": "Unit 2: Basics in Biochemistry"
    },
    {
      "question_number": "29a",
      "question_text": "Explain in details the importance of Phred Score, its different levels and how it is related to the quality of the sequencing data.",
      "marks": 12,
      "answer": "The Phred quality score (Q score) is a widely adopted metric in genomics to quantify the quality of a base call in DNA sequencing. It represents the probability that a base call is incorrect, expressed on a logarithmic scale.\n\n**Formula:**\n`Q = -10 log10(P)`\nwhere `P` is the estimated probability of the base call being incorrect.\n\n**Importance of Phred Score:**\n1.  **Quantitative Measure of Accuracy:** Phred scores provide a standardized, quantitative, and easily interpretable measure of the reliability of each base called by the sequencing instrument. A higher Phred score indicates a lower probability of error and thus higher confidence in the base call.\n2.  **Filtering and Trimming:** Researchers use Phred scores to filter out low-quality reads or to trim low-quality bases from the ends of reads before downstream analysis. This is crucial for improving the accuracy of genome assembly, variant calling, and gene expression quantification.\n3.  **Variant Calling:** In variant detection (e.g., identifying single nucleotide polymorphisms or SNPs), Phred scores are vital for distinguishing true biological variations from sequencing artifacts or errors. High quality scores are necessary to confidently call a variant.\n4.  **Genome Assembly:** For *de novo* genome assembly, high-quality reads (as indicated by high Phred scores) lead to more accurate and contiguous assemblies, reducing the number of errors and gaps in the reconstructed genome.\n5.  **Downstream Analysis Reliability:** Nearly all bioinformatics analyses that rely on sequence data benefit from, and often require, quality scores to ensure the robustness and reliability of their results. This includes alignment, mapping, and quantification.\n\n**Different Levels of Phred Score:**\nPhred scores are typically integers, and their corresponding error probabilities and accuracies are:\n*   **Q10:** P = 0.1 (1 in 10 chance of error) => 90% accuracy\n*   **Q20:** P = 0.01 (1 in 100 chance of error) => 99% accuracy (Often considered a minimum threshold for good quality reads)\n*   **Q30:** P = 0.001 (1 in 1000 chance of error) => 99.9% accuracy (Frequently desired for high-confidence variant calls)\n*   **Q40:** P = 0.0001 (1 in 10,000 chance of error) => 99.99% accuracy\n*   **Q50:** P = 0.00001 (1 in 100,000 chance of error) => 99.999% accuracy\n\n**Relation to Sequencing Data Quality:**\nPhred scores are directly related to the quality of sequencing data. Modern sequencing machines typically produce reads where most bases have a Q score of 30 or higher, especially in the central part of the read. Bases at the beginning and end of reads, or those in repetitive/difficult-to-sequence regions, often have lower quality scores. By analyzing the distribution of Phred scores across reads and within individual reads, researchers can assess the overall quality of a sequencing run, identify potential issues (e.g., adapter contamination, primer dimers), and make informed decisions about filtering and processing their data to ensure high-quality, reliable results in their biological research.",
      "answer_source": "generated",
      "chapter": "Unit 2: Basics in Biochemistry"
    },
    {
      "question_number": "29b",
      "question_text": "Explain in detail the Genbank file format with an example.",
      "marks": 12,
      "answer": "The GenBank file format is a text-based format used by the National Center for Biotechnology Information (NCBI) to represent nucleotide sequence records. It contains not only the raw sequence data but also extensive annotations, metadata, and cross-references that provide biological context. Each record in a GenBank file corresponds to a single contiguous sequence entry. The format is designed to be human-readable and organized into distinct sections:\n\nKey Sections of a GenBank Record:\n1. LOCUS: Provides a brief summary of the sequence, including the locus name, sequence length (in base pairs), molecule type (e.g., DNA), topology (linear or circular), division (e.g., PRI for primate), and date of last modification.\n2. DEFINITION: A concise description of the sequence content.\n3. ACCESSION: The unique identifier (accession number) for the sequence record.\n4. VERSION: The accession number followed by a version number (e.g., U49845.1), indicating updates to the record.\n5. KEYWORDS: Terms used to categorize the entry.\n6. SOURCE: Information about the organism from which the sequence was obtained, including its scientific name, common name, and taxonomic lineage.\n7. REFERENCES: Details of scientific publications associated with the sequence data, including authors, title, journal, and PubMed ID.\n8. FEATURES: This is a crucial section detailing the biological annotations on the sequence. It uses a specific vocabulary to describe various features (e.g., gene, CDS (Coding Sequence), mRNA, rRNA, tRNA, regulatory, misc_feature) along with their precise locations (start and end coordinates). Each feature can have qualifiers providing additional information (e.g., /gene=\"TCP1\", /product=\"TCP1-beta chain chaperonin\", /codon_start=1).\n9. ORIGIN: Marks the beginning of the actual nucleotide sequence data. The sequence follows in blocks of 60 nucleotides per line, with base numbering preceding each block.\n10. // (Double Slash): Signifies the end of a GenBank record.\n\nExample (Simplified):\nLOCUS       SCU49845               5028 bp    DNA     PRI 21-JUN-1999\nDEFINITION  Saccharomyces cerevisiae TCP1-beta gene, partial CDS.\nACCESSION   U49845\nVERSION     U49845.1  GI:1293613\nKEYWORDS    chaperonin; TCP-1-beta.\nSOURCE      Saccharomyces cerevisiae (baker's yeast)\n  ORGANISM  Saccharomyces cerevisiae\n            Eukaryota; Fungi; Ascomycota; Saccharomycotina; Saccharomycetes;\n            Saccharomycetales; Saccharomycetaceae; Saccharomyces.\nREFERENCE   1  (bases 1 to 5028)\n  AUTHORS   Wempe, F.\n  TITLE     Cloning and characterization of the TCP1-beta gene from\n            Saccharomyces cerevisiae.\n  JOURNAL   Unpublished (1998)\nFEATURES             Location/Qualifiers\n     source          1..5028\n                     /organism=\"Saccharomyces cerevisiae\"\n                     /mol_type=\"genomic DNA\"\n                     /strain=\"S288C\"\n     gene            <1..>5028\n                     /gene=\"TCP1\"\n                     /note=\"TCP1-beta chaperonin\"\n     CDS             <1..>5028\n                     /gene=\"TCP1\"\n                     /codon_start=1\n                     /product=\"TCP1-beta chain chaperonin\"\n                     /protein_id=\"AAC98114.1\"\n                     /db_xref=\"GI:1293614\"\n                     /translation=\"MSSSTKKLNNSLPKSTIKKKFLRNSKSKDLTKRKTLTKYTRTSIKKTKLTKY... (truncated)\"\nORIGIN\n        1 aaaacagtct ctggtggtgg ccctggccgg aaactccact tccgattgaa agacttcaac\n       61 gaaccttcaa accagctcct tcttcagagt tggcgtggat tcataacctt cgagattacg\n      121 atcttcacca agtctgtgat cactgtactt ggttcatcta aaatgattgc acaactatgt\n      ... (additional sequence lines)\n     4981 ccagtcgata ggcgctaaag gcgaaagctt ctaaacatat gtggctgggt ctcaaggtaa\n     5021 gcgtcatatg atattcga\n//\n\nThis comprehensive format allows researchers to not only retrieve sequences but also to understand their biological context, including their origin, known functions, and associated literature, making it a cornerstone for genomic data sharing and analysis.",
      "answer_source": "generated",
      "chapter": "Unit 2: Basics in Biochemistry"
    },
    {
      "question_number": "30a",
      "question_text": "Demonstrate the syntax for R- data-frames and matrices. Explain how different are these two to each other.",
      "marks": 12,
      "answer": "In R, both data frames and matrices are two-dimensional data structures used to store tabular data, but they differ significantly in their characteristics and use cases.\n\n**R Matrices:**\n*   **Definition:** A matrix is a two-dimensional, homogeneous data structure. This means all elements within a matrix must be of the same data type (e.g., all numeric, all character, all logical).\n*   **Syntax for Creation:** Matrices are typically created using the `matrix()` function, specifying the data, number of rows (`nrow`), number of columns (`ncol`), and how to fill the data (`byrow=TRUE` or `FALSE`).\n\n    ```R\n    # Example of a numeric matrix\n    matrix_data <- c(1, 2, 3, 4, 5, 6)\n    my_matrix <- matrix(matrix_data, nrow = 2, ncol = 3, byrow = TRUE)\n    print(\"Numeric Matrix:\")\n    print(my_matrix)\n    # Output:\n    #      [,1] [,2] [,3]\n    # [1,]    1    2    3\n    # [2,]    4    5    6\n\n    # Example of a character matrix (all elements coerced to character)\n    char_matrix <- matrix(c(\"A\", 1, \"B\", 2), nrow = 2, byrow = TRUE)\n    print(\"Character Matrix:\")\n    print(char_matrix)\n    # Output:\n    #      [,1] [,2]\n    # [1,] \"A\"  \"1\" \n    # [2,] \"B\"  \"2\" \n    ```\n\n**R Data Frames:**\n*   **Definition:** A data frame is a two-dimensional, heterogeneous data structure. It can store columns of different data types (e.g., one column can be numeric, another character, and another logical). Each column in a data frame is essentially a vector, and all columns must have the same length (number of rows).\n*   **Syntax for Creation:** Data frames are created using the `data.frame()` function, where each argument represents a column.\n\n    ```R\n    # Example of a data frame\n    my_dataframe <- data.frame(\n      Name = c(\"Alice\", \"Bob\", \"Charlie\"),\n      Age = c(25, 30, 35),\n      IsStudent = c(TRUE, FALSE, TRUE)\n    )\n    print(\"Data Frame:\")\n    print(my_dataframe)\n    # Output:\n    #      Name Age IsStudent\n    # 1   Alice  25      TRUE\n    # 2     Bob  30     FALSE\n    # 3 Charlie  35      TRUE\n\n    # Accessing columns\n    print(my_dataframe$Name)\n    print(my_dataframe[\"Age\"])\n    ```\n\n**How Data Frames and Matrices Differ:**\n1.  **Homogeneity vs. Heterogeneity:** This is the most significant difference. Matrices enforce a single data type across all their elements, whereas data frames allow different data types for each column.\n2.  **Internal Structure:** A matrix is fundamentally a vector with a `dim` attribute (dimensions: number of rows and columns). A data frame, on the other hand, is a list of vectors, where each vector (column) has the same length. This list-based structure allows for type diversity.\n3.  **Use Cases:**\n    *   **Matrices** are ideal for mathematical operations that require all elements to be of the same type, such as linear algebra, statistical modeling (e.g., regression design matrices), or image processing where pixel values are uniform.\n    *   **Data frames** are designed for tabular data, similar to spreadsheets or database tables, where each row represents an observation and each column represents a variable, potentially of different types. They are the workhorse for most statistical analysis and data manipulation tasks in R.\n4.  **Column and Row Naming:** Both can have row and column names. However, column names are an inherent and often used feature of data frames (accessed with `$`), whereas for matrices, row and column names are often used for descriptive purposes rather than direct indexing by name in the same flexible way.\n5.  **Coercion Behavior:** If you attempt to put different data types into a matrix, R will automatically coerce all elements to the most general type (e.g., if a numeric matrix contains a single character, all numbers become characters). Data frames, by design, avoid this across columns.",
      "answer_source": "generated",
      "chapter": "Unit 4: Neurobiology"
    },
    {
      "question_number": "30b",
      "question_text": "Explain in detail about datatypes in Python with suitable examples.",
      "marks": 12,
      "answer": "Python is a dynamically typed language, meaning you don't declare the type of a variable when you create it; the interpreter infers it. Python offers a rich set of built-in data types to handle various kinds of data:\n\n1.  **Numeric Types:** Used to store numerical values.\n    *   **`int` (Integer):** Represents whole numbers (positive, negative, or zero) without a decimal point. They have arbitrary precision.\n        Example:\n        age = 30\n        large_number = 12345678901234567890\n        print(type(age)) # <class 'int'>\n    *   **`float` (Floating-point number):** Represents real numbers with a decimal point or in exponential form.\n        price = 19.99\n        pi = 3.14159\n        scientific = 6.022e23\n        print(type(price)) # <class 'float'>\n    *   **`complex` (Complex number):** Represents numbers with a real and an imaginary part, written as `x + yj`.\n        z = 2 + 3j\n        print(type(z)) # <class 'complex'>\n\n2.  **Sequence Types:** Ordered collections of items.\n    *   **`str` (String):** An immutable sequence of Unicode characters, used to represent text. Strings are enclosed in single or double quotes.\n        name = \"Alice\"\n        message = 'Hello, World!'\n        print(type(name)) # <class 'str'>\n    *   **`list` (List):** A mutable (changeable), ordered sequence of items. Lists can contain items of different data types and are defined by square brackets `[]`.\n        numbers = [1, 2, 3, 4, 5]\n        mixed_list = [\"apple\", 10, True]\n        numbers.append(6)\n        print(type(numbers)) # <class 'list'>\n    *   **`tuple` (Tuple):** An immutable (unchangeable), ordered sequence of items. Tuples are defined by parentheses `()` and are often used for heterogeneous data that should not be modified.\n        coordinates = (10, 20)\n        rgb_color = (255, 0, 0)\n        print(type(coordinates)) # <class 'tuple'>\n\n3.  **Mapping Type:**\n    *   **`dict` (Dictionary):** An unordered, mutable collection of key-value pairs. Keys must be unique and immutable (like strings or tuples), while values can be of any data type. Defined by curly braces `{}`.\n        person = {\"name\": \"Bob\", \"age\": 30, \"city\": \"New York\"}\n        print(person[\"name\"])\n        person[\"age\"] = 31\n        print(type(person)) # <class 'dict'>\n\n4.  **Set Types:** Unordered collections of unique items.\n    *   **`set` (Set):** A mutable, unordered collection of unique and immutable items. Defined by curly braces `{}` or `set()`.\n        unique_numbers = {1, 2, 2, 3, 4}\n        print(unique_numbers) # {1, 2, 3, 4}\n        print(type(unique_numbers)) # <class 'set'>\n    *   **`frozenset` (Frozenset):** An immutable version of a set.\n        immutable_set = frozenset([1, 2, 3])\n        print(type(immutable_set)) # <class 'frozenset'>\n\n5.  **Boolean Type:**\n    *   **`bool` (Boolean):** Represents truth values: `True` or `False`. Used for logical operations.\n        is_active = True\n        is_logged_in = False\n        print(type(is_active)) # <class 'bool'>\n\n6.  **None Type:**\n    *   **`NoneType`:** Represents the absence of a value or a null value. It's often used to indicate that a function doesn't return anything or that a variable has not yet been assigned a meaningful value.\n        result = None\n        print(type(result)) # <class 'NoneType'>\n\nUnderstanding these data types is crucial for writing effective and efficient Python code, as the choice of data type influences how data is stored, manipulated, and interpreted within a program.",
      "answer_source": "generated",
      "chapter": "Unit 4: Neurobiology"
    },
    {
      "question_number": "31a",
      "question_text": "Explain in detail basic interval operations for GRanges object.",
      "marks": 12,
      "answer": "The `GRanges` (Genomic Ranges) object is a fundamental data structure in Bioconductor for representing genomic intervals. It extends the `IRanges` (Integer Ranges) concept by adding genomic context (sequence name/chromosome, strand, and optional metadata). `GRanges` objects are essential for working with high-throughput sequencing data, where operations on genomic regions are commonplace. The core functionality relies on powerful interval operations, many of which are inherited or adapted from the `IRanges` package.\n\nHere are some basic and important interval operations for `GRanges` objects:\n\n1.  **`start()`, `end()`, `width()`:**\n    *   These functions extract the start position, end position, and width (length) of each genomic range, respectively.\n    *   **Example:**\n        ```R\n        library(GenomicRanges)\n        gr <- GRanges(seqnames = Rle(c(\"chr1\", \"chr2\", \"chr1\"), c(1, 1, 1)),\n                      ranges = IRanges(start = c(10, 20, 50), end = c(30, 40, 70)),\n                      strand = Rle(c(\"+\", \"-\", \"+\"), c(1, 1, 1)))\n        print(start(gr)) # Output: [1] 10 20 50\n        print(width(gr)) # Output: [1] 21 21 21\n        ```\n\n2.  **`range()`:**\n    *   This operation computes the smallest `GRanges` object that spans all the ranges within the input `GRanges` object, typically collapsing ranges on the same sequence and strand into a single, encompassing range.\n    *   **Example:**\n        ```R\n        gr_expanded <- range(gr)\n        print(gr_expanded)\n        # Output would show a new GRanges object with fewer ranges, each representing the full span on its respective chr/strand.\n        # chr1 +: 10-70\n        # chr2 -: 20-40\n        ```\n\n3.  **`reduce()`:**\n    *   `reduce()` merges overlapping or adjacent genomic ranges on the same sequence and strand into a set of non-overlapping, consolidated ranges. This is very useful for collapsing redundant or contiguous features.\n    *   **Example:**\n        ```R\n        gr_overlap <- GRanges(seqnames = \"chr1\",\n                              ranges = IRanges(start = c(10, 15, 30), end = c(20, 25, 40)),\n                              strand = \"+\")\n        reduced_gr <- reduce(gr_overlap)\n        print(reduced_gr)\n        # Output: A single range for chr1 +: 10-40 (merges 10-20, 15-25, 30-40)\n        ```\n\n4.  **`disjoin()`:**\n    *   In contrast to `reduce()`, `disjoin()` creates a new `GRanges` object that contains all unique, non-overlapping intervals defined by the input ranges. It effectively 'cuts up' overlapping regions into minimal segments.\n    *   **Example:**\n        ```R\n        disjoint_gr <- disjoin(gr_overlap)\n        print(disjoint_gr)\n        # Output: multiple disjoint ranges: 10-14, 15-20, 21-25, 30-40 (conceptual)\n        ```\n\n5.  **`gaps()`:**\n    *   `gaps()` identifies the regions *between* the input ranges. It returns a `GRanges` object representing the uncovered regions within the span of the original ranges (or a specified universe).\n    *   **Example:**\n        ```R\n        gr_sparse <- GRanges(seqnames = \"chr1\",\n                             ranges = IRanges(start = c(1, 10), end = c(5, 15)),\n                             strand = \"*\")\n        gaps_gr <- gaps(gr_sparse, start = 1, end = 20) # Gaps within 1 to 20\n        print(gaps_gr)\n        # Output: Ranges like chr1 *: 6-9, chr1 *: 16-20\n        ```\n\n6.  **Set Operations (`union()`, `intersect()`, `setdiff()`):**\n    *   These functions perform standard set operations on `GRanges` objects, considering both coordinates and genomic context.\n    *   `union(gr1, gr2)`: Combines all ranges from `gr1` and `gr2`, merging overlaps.\n    *   `intersect(gr1, gr2)`: Returns only the regions that are common (overlap) between `gr1` and `gr2`.\n    *   `setdiff(gr1, gr2)`: Returns regions in `gr1` that do *not* overlap with `gr2`.\n\n7.  **`flank()`:**\n    *   `flank()` extends ranges upstream or downstream by a specified `width`, based on the strand information. This is useful for identifying promoter regions or regulatory elements adjacent to genes.\n    *   **Example:**\n        ```R\n        gr_flanked <- flank(gr, width = 100, start = TRUE) # 100bp upstream\n        print(gr_flanked)\n        ```\n\n8.  **`resize()`:**\n    *   `resize()` changes the width of ranges to a new specified size, fixing either the start, end, or center position. Useful for making all regions a uniform length.\n    *   **Example:**\n        ```R\n        gr_resized <- resize(gr, width = 50, fix = \"center\")\n        print(gr_resized)\n        ```\n\nThese operations, combined with flexible subsetting and metadata handling, make `GRanges` an incredibly powerful and versatile data structure for almost any genomic interval analysis in computational biology.",
      "answer_source": "generated",
      "chapter": "Unit 2: Basics in Biochemistry"
    },
    {
      "question_number": "31b",
      "question_text": "Explain in detail about the IRanges package and demonstrate any five of them.",
      "marks": 12,
      "answer": "The `IRanges` package is a fundamental component of the Bioconductor project in R, providing highly efficient and flexible data structures and methods for manipulating integer ranges. While `GRanges` objects build upon `IRanges` by adding genomic context (sequence name, strand), `IRanges` focuses purely on the arithmetic and set operations of integer intervals (start, end, and width), making it a cornerstone for handling coordinate-based data.\n\n**The `IRanges` Object:**\nAt its core, `IRanges` defines the `IRanges` object, which is a vector-like container for storing a set of integer ranges. Each range is defined by a `start` position, an `end` position, and a `width`. It is optimized for performance when dealing with large numbers of ranges and allows for rich metadata associated with each range.\n\n**Five Demonstrations of `IRanges` Operations:**\n\nTo use `IRanges`, you first load the package:\n```R\nlibrary(IRanges)\n```\n\n1.  **Construction of `IRanges` objects:**\n    You can create `IRanges` objects by specifying `start` and `end`, `start` and `width`, or `end` and `width`.\n    ```R\n    # Using start and end\n    ir1 <- IRanges(start = c(1, 10, 20), end = c(5, 15, 25))\n    print(\"IRanges object created with start and end:\")\n    print(ir1)\n    # Output:\n    # IRanges object with 3 ranges and 0 metadata columns:\n    #           start   end width\n    #       [1]     1     5     5\n    #       [2]    10    15     6\n    #       [3]    20    25     6\n\n    # Using start and width\n    ir2 <- IRanges(start = c(5, 12), width = c(3, 8))\n    print(\"IRanges object created with start and width:\")\n    print(ir2)\n    # Output:\n    # IRanges object with 2 ranges and 0 metadata columns:\n    #           start   end width\n    #       [1]     5     7     3\n    #       [2]    12    19     8\n    ```\n\n2.  **`reduce()` - Merging Overlapping/Adjacent Ranges:**\n    This function combines all overlapping or adjacent ranges into a set of non-overlapping ranges. It's crucial for collapsing redundant features.\n    ```R\n    ir_overlap <- IRanges(start = c(1, 5, 12, 18), end = c(7, 10, 15, 20))\n    print(\"Original overlapping IRanges:\")\n    print(ir_overlap)\n    # Output:\n    # IRanges object with 4 ranges:\n    #           start   end width\n    #       [1]     1     7     7\n    #       [2]     5    10     6\n    #       [3]    12    15     4\n    #       [4]    18    20     3\n\n    reduced_ir <- reduce(ir_overlap)\n    print(\"Reduced (merged) IRanges:\")\n    print(reduced_ir)\n    # Output:\n    # IRanges object with 2 ranges:\n    #           start   end width\n    #       [1]     1    10    10  # Merges 1-7 and 5-10\n    #       [2]    12    20     9  # Merges 12-15 and 18-20\n    ```\n\n3.  **`findOverlaps()` - Detecting Overlaps Between Two Sets of Ranges:**\n    This function identifies which ranges in a 'query' `IRanges` object overlap with which ranges in a 'subject' `IRanges` object, returning an `Hits` object.\n    ```R\n    ir_a <- IRanges(start = c(1, 10, 25), end = c(5, 15, 30))\n    ir_b <- IRanges(start = c(3, 12, 28), end = c(7, 18, 32))\n    overlaps <- findOverlaps(ir_a, ir_b)\n    print(\"Overlaps between ir_a and ir_b:\")\n    print(overlaps)\n    # Output:\n    # Hits object with 3 hits and 0 metadata columns:\n    #       queryHits subjectHits\n    #       <integer>   <integer>\n    #   [1]         1           1  # ir_a[1] (1-5) overlaps ir_b[1] (3-7)\n    #   [2]         2           2  # ir_a[2] (10-15) overlaps ir_b[2] (12-18)\n    #   [3]         3           3  # ir_a[3] (25-30) overlaps ir_b[3] (28-32)\n    ```\n\n4.  **`subsetByOverlaps()` - Subsetting Based on Overlaps:**\n    This function is a convenient way to filter an `IRanges` object, retaining only those ranges that overlap with another specified `IRanges` object.\n    ```R\n    # Using ir_a and ir_b from above\n    subset_ir_a <- subsetByOverlaps(ir_a, ir_b)\n    print(\"Ranges in ir_a that overlap with ir_b:\")\n    print(subset_ir_a)\n    # Output:\n    # IRanges object with 3 ranges:\n    #           start   end width\n    #       [1]     1     5     5\n    #       [2]    10    15     6\n    #       [3]    25    30     6\n    ```\n\n5.  **Arithmetic Operations - `shift()` (Shifting Ranges):**\n    `IRanges` supports various arithmetic operations. `shift()` moves all ranges by a specified integer amount.\n    ```R\n    ir_original <- IRanges(start = c(10, 20), width = c(5, 10))\n    print(\"Original IRanges:\")\n    print(ir_original)\n    # Output:\n    # IRanges object with 2 ranges:\n    #           start   end width\n    #       [1]    10    14     5\n    #       [2]    20    29    10\n\n    ir_shifted <- shift(ir_original, shift = 5)\n    print(\"IRanges shifted by +5:\")\n    print(ir_shifted)\n    # Output:\n    # IRanges object with 2 ranges:\n    #           start   end width\n    #       [1]    15    19     5\n    #       [2]    25    34    10\n    ```\n\n`IRanges` provides a robust and efficient framework for low-level integer interval manipulations, which is critical for foundational tasks in genomics like processing alignments, annotating features, and performing spatial queries on genomic coordinates.",
      "answer_source": "generated",
      "chapter": "Unit 2: Basics in Biochemistry"
    },
    {
      "question_number": "32a",
      "question_text": "Explain MutableSeq objects.",
      "marks": 12,
      "answer": "In Biopython, a `MutableSeq` object is a sequence object that, unlike the standard `Seq` object, allows for in-place modification of its sequence content. This mutability makes it useful for scenarios where a sequence needs to be frequently altered without creating new objects for each change.\n\n**Key Characteristics of `MutableSeq`:**\n\n1.  **Mutability:** The most defining characteristic. You can change individual bases or entire segments of a `MutableSeq` directly by assignment, similar to how elements in a Python list are modified.\n    *   **Contrast with `Seq`:** A standard `Bio.Seq.Seq` object is immutable. Any operation that seemingly modifies a `Seq` (e.g., slicing, concatenation) actually returns a *new* `Seq` object, leaving the original unchanged. This immutability is beneficial for thread safety and ensuring sequence integrity.\n\n2.  **Efficiency for Frequent Modifications:** For tasks involving numerous localized changes, insertions, or deletions within a sequence, using a `MutableSeq` can be more efficient than repeatedly creating new `Seq` objects, which might incur overhead due to memory allocation and copying.\n\n3.  **Methods for Modification:** `MutableSeq` objects support various list-like methods for in-place modification:\n    *   `append(char)`: Adds a character to the end of the sequence.\n    *   `extend(seq_obj)`: Extends the sequence by appending all items from an iterable.\n    *   `insert(index, char)`: Inserts a character at a specified index.\n    *   `remove(char)`: Removes the first occurrence of a character.\n    *   `pop(index)`: Removes and returns the item at a given index.\n    *   Direct indexing and slicing for assignment (e.g., `mutable_seq[i] = 'X'`, `mutable_seq[start:end] = '...'`).\n\n4.  **Conversion:**\n    *   A `Seq` object can be converted to a `MutableSeq` using the `.tomutable()` method.\n    *   A `MutableSeq` can be converted back to an immutable `Seq` object using the `.toseq()` method.\n\n5.  **Alphabet Awareness:** Like `Seq` objects, `MutableSeq` objects are associated with an alphabet, which helps in validation (e.g., ensuring only valid DNA bases are inserted into a DNA sequence).\n\n**Example of `MutableSeq` in Action:**\n\n```python\nfrom Bio.Seq import Seq, MutableSeq\nfrom Bio.Alphabet import IUPAC\n\n# Create an immutable Seq object\nimmutable_dna = Seq(\"ATGCGT\", IUPAC.unambiguous_dna)\nprint(f\"Original Immutable Seq: {immutable_dna}\")\n\n# Convert to a MutableSeq\nmutable_dna = immutable_dna.tomutable()\nprint(f\"Initial Mutable Seq:    {mutable_dna}\")\n\n# --- Perform modifications ---\n\n# 1. Change a single base\nmutable_dna[2] = 'A' # Change 'G' at index 2 to 'A'\nprint(f\"After changing index 2: {mutable_dna}\") # Output: ATACGT\n\n# 2. Change a slice of bases\nmutable_dna[3:5] = 'TT' # Change 'CG' at indices 3-4 to 'TT'\nprint(f\"After changing slice 3: {mutable_dna}\") # Output: ATATTT\n\n# 3. Append a base\nmutable_dna.append('A')\nprint(f\"After appending 'A':    {mutable_dna}\") # Output: ATATTTA\n\n# 4. Insert a base\nmutable_dna.insert(1, 'G') # Insert 'G' at index 1\nprint(f\"After inserting 'G':    {mutable_dna}\") # Output: AGTATTTA\n\n# --- Convert back to immutable Seq ---\nfinal_immutable_dna = mutable_dna.toseq()\nprint(f\"Final Immutable Seq:    {final_immutable_dna}\")\n```\n\nIn summary, `MutableSeq` offers flexibility for in-place modifications, contrasting with the immutable nature of `Seq` objects. The choice between them depends on whether the sequence is expected to remain constant or undergo frequent alterations during processing.",
      "answer_source": "generated",
      "chapter": "Unit 4: Neurobiology"
    },
    {
      "question_number": "32b",
      "question_text": "Illustrate the use of Biopython module to perform translation.",
      "marks": 12,
      "answer": "Biopython's `Bio.Seq` module provides a straightforward and powerful way to perform genetic code translation from DNA or RNA sequences into protein sequences. This functionality is encapsulated in the `.translate()` method of `Seq` objects, allowing users to specify different genetic codes and control how stop codons are handled.\n\n**Core Principle of Translation:**\nTranslation is the biological process where the genetic code carried by mRNA is decoded to produce a specific protein. In Biopython, you typically start with a DNA or RNA `Seq` object, and the `translate()` method simulates this process, reading codons (three-nucleotide sequences) and converting them into amino acids.\n\n**Key Parameters of `.translate()`:**\n1.  **`table` (optional):** Specifies which genetic code table to use. By default, it uses the standard genetic code (table 1). Other tables can be specified by their NCBI identifier (e.g., `table=2` for Vertebrate Mitochondrial, `table=11` for Bacterial, Archaeal, and Plant Plastid).\n2.  **`to_stop` (optional):** A boolean parameter. If `True`, translation will terminate at the first stop codon encountered, and the stop codon itself will not be translated (resulting in a truncated protein sequence). If `False` (the default), stop codons are translated into an asterisk (`*`) character in the protein sequence.\n3.  **`cds` (optional):** A boolean parameter. If `True`, the method assumes the input sequence is a complete Coding Sequence (CDS) and performs checks, such as ensuring it starts with a valid start codon and, if `to_stop=True`, ends with a stop codon. It will raise an error if these conditions are not met, helping to validate the coding region.\n\n**Illustrative Examples:**\n\n```python\nfrom Bio.Seq import Seq\nfrom Bio.Alphabet import IUPAC\n\n# 1. Basic Translation with a DNA sequence (default: standard code, includes stop codons as '*')\n# Sequence: ATGGCCATTGTAATGGGCCGCTGAAAGGGTGCCCGAA\n# Codons:   ATG GCC ATT GTA ATG GGC CGC TGA AAG GGT GCC CGA A\n# Note: 'TGA' is a stop codon in the standard genetic code.\n\ndna_seq = Seq(\"ATGGCCATTGTAATGGGCCGCTGAAAGGGTGCCCGAA\", IUPAC.unambiguous_dna)\nprint(f\"Original DNA sequence:  {dna_seq}\")\n\nprotein_default = dna_seq.translate()\nprint(f\"Translated protein (default): {protein_default}\")\n# Expected output: MAIVMGR*KGAR (TGA becomes '*')\n\n# 2. Translation stopping at the first stop codon (`to_stop=True`)\nprotein_to_stop = dna_seq.translate(to_stop=True)\nprint(f\"Translated protein (to_stop=True): {protein_to_stop}\")\n# Expected output: MAIVMGR (Translation stops at TGA)\n\n# 3. Translation with a specific genetic code table (e.g., Vertebrate Mitochondrial Code, table=2)\n# In the Vertebrate Mitochondrial code (table=2):\n#   'TGA' codes for Tryptophan (W), not a stop codon.\n#   'AGA' and 'AGG' are stop codons.\n# Let's use a sequence to highlight 'TGA' difference.\n\ndna_mito_test = Seq(\"ATGACAGTGATA\", IUPAC.unambiguous_dna)\nprint(f\"\\nDNA sequence for mitochondrial test: {dna_mito_test}\")\n\n# Standard code (table=1): TGA is Stop\nprotein_standard_mito = dna_mito_test.translate(to_stop=True, table=1)\nprint(f\"Standard code (TGA is STOP): {protein_standard_mito}\") # MT\n\n# Vertebrate Mitochondrial code (table=2): TGA is Tryptophan (W)\nprotein_mito = dna_mito_test.translate(to_stop=True, table=2)\nprint(f\"Mitochondrial code (TGA is Trp): {protein_mito}\") # MTW (Translation continues past TGA if there's no other stop)\n# Note: If a stop codon (like TAA/TAG) was present later and also a stop in table=2, it would stop there.\n\n# 4. Translation of an RNA sequence\nrna_seq = Seq(\"AUGGCCAUUGUAAUGGGCCGCUGAAAGGGUGCCCGAA\", IUPAC.unambiguous_rna)\nprint(f\"\\nOriginal RNA sequence: {rna_seq}\")\nprotein_from_rna = rna_seq.translate(to_stop=True)\nprint(f\"Translated protein from RNA: {protein_from_rna}\") # MAIVMGR\n\n# 5. Using `cds=True` for strict coding sequence validation\n# dna_seq has a start codon (ATG) and a stop codon (TGA).\n# This will work as it matches the definition of a CDS.\nprotein_cds_valid = dna_seq.translate(to_stop=True, cds=True)\nprint(f\"\\nTranslated protein (validated CDS): {protein_cds_valid}\") # MAIVMGR\n\n# Example of `cds=True` failing (e.g., if no stop codon is found at the end when `to_stop=True`)\n# This would raise a ValueError: 'Stop codon not found'\n# short_dna = Seq(\"ATGGCCATTGTA\", IUPAC.unambiguous_dna)\n# protein_cds_fail = short_dna.translate(to_stop=True, cds=True)\n```\n\nBiopython's translation capabilities are indispensable for tasks such as gene prediction validation, sequence annotation, and comparative genomics studies, enabling accurate and context-aware conversion of nucleic acid sequences to their protein counterparts.",
      "answer_source": "generated",
      "chapter": "Unit 3: Structure Biology"
    }
  ]
}